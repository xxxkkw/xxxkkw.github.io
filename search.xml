<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AscendC算子</title>
      <link href="/2024/10/18/AscendC%E7%AE%97%E5%AD%90/"/>
      <url>/2024/10/18/AscendC%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>AscendC算子原生支持C和C++标准规范,主要运行在Ascend系列产品上。因为是直接运行在npu上的算子函数，所以涉及到比较多的内存处理，包括一些数据搬移，内存管理，队列管理，还是比较的繁琐，但好在官方提供了编程范式，只需要按照所给的框架就能完成算子的实现。<br>开发者主要做的就是确定任务，设计算子，实现计算功能。<br>明确矢量算子的输入以及输出。Ascend C提供的矢量计算接口的操作元素都为LocalTensor，输入数据需要先搬运进AI Core的内部存储Local Memory，然后使用自定义Compute函数计算接口完成，得到最终结果，再搬出到外部存储Global Memory上。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel_operator.h&quot;</span><br><span class="line">using namespace AscendC;</span><br><span class="line"></span><br><span class="line">constexpr int32_t TOTAL_LENGTH = 8 * 2048;                            // total length of data</span><br><span class="line">constexpr int32_t USE_CORE_NUM = 8;                                   // num of core used</span><br><span class="line">constexpr int32_t BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         // length computed of each core</span><br><span class="line">constexpr int32_t TILE_NUM = 8;                                       // split data into 8 tiles for each core</span><br><span class="line">constexpr int32_t BUFFER_NUM = 2;                                     // tensor num for each queue</span><br><span class="line">constexpr int32_t TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; // seperate to 2 parts, due to double buffer</span><br><span class="line"></span><br><span class="line">class KernelAdd &#123;</span><br><span class="line">public:</span><br><span class="line">    __aicore__ inline KernelAdd() &#123;&#125;</span><br><span class="line">    __aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z) //初始化输入输出</span><br><span class="line">    &#123;</span><br><span class="line">        xGm.SetGlobalBuffer((__gm__ half *)x + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">        yGm.SetGlobalBuffer((__gm__ half *)y + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">        zGm.SetGlobalBuffer((__gm__ half *)z + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">        pipe.InitBuffer(inQueueX, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">        pipe.InitBuffer(inQueueY, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">        pipe.InitBuffer(outQueueZ, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void Process() //实现流水操作</span><br><span class="line">    &#123;</span><br><span class="line">        int32_t loopCount = TILE_NUM * BUFFER_NUM;</span><br><span class="line">        for (int32_t i = 0; i &lt; loopCount; i++) &#123;</span><br><span class="line">            CopyIn(i);</span><br><span class="line">            Compute(i);</span><br><span class="line">            CopyOut(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    __aicore__ inline void CopyIn(int32_t progress) //数据拷贝，入队</span><br><span class="line">    &#123;</span><br><span class="line">        LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();</span><br><span class="line">        LocalTensor&lt;half&gt; yLocal = inQueueY.AllocTensor&lt;half&gt;();</span><br><span class="line">        DataCopy(xLocal, xGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">        DataCopy(yLocal, yGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">        inQueueX.EnQue(xLocal);</span><br><span class="line">        inQueueY.EnQue(yLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void Compute(int32_t progress) //核心计算过程，算法实现最核心的部分</span><br><span class="line">    &#123;</span><br><span class="line">        LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;(); //这两个LocalTensor就是实际函数的输入值，通过一系列数据搬移到了这，开始计算</span><br><span class="line">        LocalTensor&lt;half&gt; yLocal = inQueueY.DeQue&lt;half&gt;();</span><br><span class="line">        LocalTensor&lt;half&gt; zLocal = outQueueZ.AllocTensor&lt;half&gt;(); //初始化输出对象，等下准备丢进输出队列</span><br><span class="line">        Add(zLocal, xLocal, yLocal, TILE_LENGTH);</span><br><span class="line">        outQueueZ.EnQue&lt;half&gt;(zLocal); //在这里丢进输出队列</span><br><span class="line">        inQueueX.FreeTensor(xLocal); //释放空间</span><br><span class="line">        inQueueY.FreeTensor(yLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void CopyOut(int32_t progress) //数据搬出</span><br><span class="line">    &#123;</span><br><span class="line">        LocalTensor&lt;half&gt; zLocal = outQueueZ.DeQue&lt;half&gt;();</span><br><span class="line">        DataCopy(zGm[progress * TILE_LENGTH], zLocal, TILE_LENGTH);</span><br><span class="line">        outQueueZ.FreeTensor(zLocal);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    TPipe pipe;</span><br><span class="line">    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX, inQueueY;</span><br><span class="line">    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueZ;</span><br><span class="line">    GlobalTensor&lt;half&gt; xGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; yGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; zGm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __global__ __aicore__ void add_custom(GM_ADDR x, GM_ADDR y, GM_ADDR z) //核函数，作为整个功能的接口</span><br><span class="line">&#123;</span><br><span class="line">    KernelAdd op;</span><br><span class="line">    op.Init(x, y, z);</span><br><span class="line">    op.Process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
          <category> Ascend </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基于yolov5的羽毛球轨迹识别</title>
      <link href="/2024/10/18/yolov5/"/>
      <url>/2024/10/18/yolov5/</url>
      
        <content type="html"><![CDATA[<p>yolov5是一种很流行的目标检测系统，基于这套系统，我们可以很轻松的开发各种识别物体的项目，不过需要自己准备数据集，以及一定的计算资源。<br>本质上来说，yolov5也是一个基于深度学习的视觉识别系统，效果很不错，就省去了自己开发的过程。同时还可以在源代码上修改，来实现自己的需求。<br>首先从部署yolov5开始：<br>部署的环境是基于python的，为了方便管理，我们使用anaconda创建一个新的虚拟环境，以便跟别的环境隔离开，这样就不会冲突。<br>在命令行中输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5 python=3.10</span><br></pre></td></tr></table></figure><br>然后再输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure><br>这样就创建好并且进入了一个新的环境内。接下来克隆官方仓库并且安装依赖项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5</span><br><span class="line">cd yolov5</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><br>如果有N卡的话还得下载对应的cuda<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure><br>到这里yolov5的环境就配置好了。随便跑点样例实验一下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --device 0</span><br></pre></td></tr></table></figure><br>这就是一个最简单的训练的代码，使用的是官方的数据集，训练后的模型存储在 runs/train/exp/weights/best.pt<br>尝试用模型检测一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect.py --device 0</span><br></pre></td></tr></table></figure><br>检测的结果会在 runs/detect/exp中<br>上面是一些比较简单的配置还有验证的过程，接下来的是最重要的，想要对一个物体进行识别，首先得有数据集，然后基于这个数据集进行训练，因为网上实在没有羽毛球的模型，我就自己框了大概1500张图，分割三分之一作为验证集，剩下的作为训练集。框图可以用这个<a href="http://makesense.bimant.com/">网站</a><br>框图之后会得到一份标签集，可以使用下面的代码分割训练集验证集<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">image_folder = &#x27;path/to/images&#x27;  # 图片文件夹路径</span><br><span class="line">label_folder = &#x27;path/to/labels&#x27;  # 标签文件夹路径</span><br><span class="line"></span><br><span class="line">val_image_folder = &#x27;path/to/val_images&#x27;  # 验证集图片存放路径</span><br><span class="line">val_label_folder = &#x27;path/to/val_labels&#x27;  # 验证集标签存放路径</span><br><span class="line"></span><br><span class="line">os.makedirs(val_image_folder, exist_ok=True)</span><br><span class="line">os.makedirs(val_label_folder, exist_ok=True)</span><br><span class="line"></span><br><span class="line">image_files = sorted(os.listdir(image_folder))</span><br><span class="line">label_files = sorted(os.listdir(label_folder))</span><br><span class="line"></span><br><span class="line">if len(image_files) != len(label_files):</span><br><span class="line">raise ValueError(&quot;图片和标签数量不匹配！请检查文件夹内容。&quot;)</span><br><span class="line"></span><br><span class="line">for i, image_file in enumerate(image_files):</span><br><span class="line">if (i + 1) % 3 == 0:  # 每三张图片选一张</span><br><span class="line"># 获取对应的标签文件名</span><br><span class="line">label_file = label_files[i]</span><br><span class="line"></span><br><span class="line">        image_path = os.path.join(image_folder, image_file)</span><br><span class="line">        label_path = os.path.join(label_folder, label_file)</span><br><span class="line">        </span><br><span class="line">        shutil.move(image_path, os.path.join(val_image_folder, image_file))</span><br><span class="line">        shutil.move(label_path, os.path.join(val_label_folder, label_file))</span><br><span class="line">        </span><br><span class="line">print(&quot;验证集划分完成！&quot;)</span><br></pre></td></tr></table></figure><br>然后再对分割好的数据集去训练<br>下面是基于项目需求，对代码的修改<br>首先添加一个元组，并且生成一个背景，用于绘制我们的轨迹<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_centers = []</span><br><span class="line">canvas = np.ones((im0s.shape[0], im0s.shape[1], 3), dtype=np.uint8) * 255</span><br></pre></td></tr></table></figure><br>用来存储我们识别到的羽毛球在空间中的坐标<br>然后在识别到目标之后，把原代码的框选修改为点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x_center = (xyxy[0] + xyxy[2]) / 2</span><br><span class="line">y_center = (xyxy[1] + xyxy[3]) / 2</span><br><span class="line">#LOGGER.info(&quot;x_center: %f, y_center: %f&quot;, x_center, y_center)</span><br><span class="line">all_centers.append((x_center, y_center))</span><br><span class="line">radius = 10</span><br><span class="line">color = (0, 0, 255)</span><br><span class="line">cv2.circle(imc, (int(x_center), int(y_center)), radius, color, thickness=-1)</span><br></pre></td></tr></table></figure><br>然后再遍历我们的坐标，将点绘制在背景上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for x_center , y_center in all_centers:</span><br><span class="line">    cv2.circle(canvas, (int(x_center), int(y_center)), 10, (0, 0, 255), -1)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">save_path = increment_path(Path(project) / name, exist_ok=exist_ok)</span><br><span class="line">save_path.mkdir(parents=True, exist_ok=True)</span><br><span class="line">final_save_path = save_path / &quot;all_centers.jpg&quot;</span><br><span class="line">cv2.imwrite(str(final_save_path), canvas)</span><br></pre></td></tr></table></figure><br>然后就可以得到羽毛球的轨迹啦<br>其实最开始是打算做类似鹰眼的轨迹识别加预测，但是预测的过程太过于复杂，折腾了一堆东西没有什么进展就over了</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，FM0编解码代码</title>
      <link href="/2024/10/17/FM0/"/>
      <url>/2024/10/17/FM0/</url>
      
        <content type="html"><![CDATA[<p>使用matlab编写的一份用于编解码信号的.m文件<br>密勒码解码过程可以表述为：以 2 倍的数据时钟码读入，进行每两位转换一次，01 和 10 都转换为 1，00 和 11 都转换为 0，这样即完成解码得到原始 NRZ 码，本实验无起始同步和停止过程<br>本代码参照密勒码的文件修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">x = [1 0 1 1 0 0 0 1];</span><br><span class="line">FM0 = zeros(1, 2 * length(x));</span><br><span class="line">state = 0;</span><br><span class="line"></span><br><span class="line">for i = 1:length(x)</span><br><span class="line">    if x(i) == 1</span><br><span class="line">        FM0(2*i-1) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">        FM0(2*i) = state;</span><br><span class="line">    else</span><br><span class="line">        FM0(2*i-1) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">        FM0(2*i) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 1);</span><br><span class="line">stairs(0:length(x)-1, x, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;原始数据&#x27;);</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 2);</span><br><span class="line">stairs(0:length(FM0)-1, FM0, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;FM0 编码结果&#x27;);</span><br><span class="line"></span><br><span class="line">decoded_data = zeros(1, length(FM0) / 2);</span><br><span class="line"></span><br><span class="line">for i = 1:2:length(FM0)-2</span><br><span class="line">    if (FM0(i) ~= FM0(i+1)) &amp;&amp; (FM0(i+1) == FM0(i+2))</span><br><span class="line">        decoded_data((i+1)/2) = 1;</span><br><span class="line">    else</span><br><span class="line">        decoded_data((i+1)/2) = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 1);</span><br><span class="line">stairs(0:length(decoded_data)-1, decoded_data, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;FM0 解码结果&#x27;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随便写点</title>
      <link href="/2024/10/15/start/"/>
      <url>/2024/10/15/start/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客! 如果感兴趣的话就多逛逛。不定期更新项目的经历，记录自己走过的路。这是我的<a href="https://github.com/xxxkkw">代码仓库</a>。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
