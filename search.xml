<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>AscendC算子中级认证</title>
      <link href="/2024/10/21/AscendC%E7%AE%97%E5%AD%90%E4%B8%AD%E7%BA%A7%E8%AE%A4%E8%AF%81/"/>
      <url>/2024/10/21/AscendC%E7%AE%97%E5%AD%90%E4%B8%AD%E7%BA%A7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>AscendC算子中级认证的题目是模拟numpy中的sinh算子，编写基于AscendC的算子sinh，命名为sinhCustom，并编写kernel侧代码，host侧代码，使用aclnn算子调用测试<br>sinh的算法实现为： sinh(x) = (exp(x) - exp(-x)) / 2.0<br>首先在kernel侧，修改sinh_custom.cpp文件，完成算子最核心的部分<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel_operator.h&quot;</span><br><span class="line">using namespace AscendC;</span><br><span class="line">constexpr int32_t TOTAL_LENGTH = 8 * 2048;                            // 数据总长度</span><br><span class="line">constexpr int32_t USE_CORE_NUM = 8;                                   // 使用核心数量</span><br><span class="line">constexpr int32_t BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         // 每个核计算的数据长度</span><br><span class="line">constexpr int32_t TILE_NUM = 8;                                       // 将数据为每个核心分成8个区块</span><br><span class="line">constexpr int32_t BUFFER_NUM = 2;                                     // 每个队列的张量数量</span><br><span class="line">constexpr int32_t TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; // 利用双缓冲技术，将某个对象或数据分为两部分处理</span><br><span class="line"></span><br><span class="line">class KernelSinh&#123;</span><br><span class="line">public:</span><br><span class="line">    __aicore__ inline KernelSinh()&#123;&#125;</span><br><span class="line">    __aicore__ inline void Init(GM_ADDR x, GM_ADDR z,uint32_t totalLength,uint32_t tileNum) //初始化输入输出</span><br><span class="line">    &#123;</span><br><span class="line">        ASSERT(GetBlockNum() != 0 &amp;&amp; &quot;block dim can not be zero!&quot;);</span><br><span class="line">        this-&gt;blockLength = totalLength / GetBlockNum();</span><br><span class="line">        this-&gt;tileNum = tileNum;</span><br><span class="line">        ASSERT(tileNum != 0 &amp;&amp; &quot;tile num can not be zero!&quot;);</span><br><span class="line">        this-&gt;tileLength = this-&gt;blockLength / tileNum / BUFFER_NUM;</span><br><span class="line"></span><br><span class="line">        xGm.SetGlobalBuffer((__gm__ DTYPE_X *)x + this-&gt;blockLength * GetBlockIdx(),this-&gt;blockLength);</span><br><span class="line">        zGm.SetGlobalBuffer((__gm__ DTYPE_Z *)z + this-&gt;blockLength * GetBlockIdx(),this-&gt;blockLength);</span><br><span class="line">        pipe.InitBuffer(inQueueX, BUFFER_NUM, this-&gt;tileLength * sizeof(DTYPE_X)); //初始化内存</span><br><span class="line">        pipe.InitBuffer(outQueueZ, BUFFER_NUM, this-&gt;tileLength * sizeof(DTYPE_Z));</span><br><span class="line">        pipe.InitBuffer(tmpBuffer1, this-&gt;tileLength * sizeof(DTYPE_X));</span><br><span class="line">        pipe.InitBuffer(tmpBuffer2, this-&gt;tileLength * sizeof(DTYPE_X));</span><br><span class="line">        pipe.InitBuffer(tmpBuffer3, this-&gt;tileLength * sizeof(DTYPE_X));</span><br><span class="line">        pipe.InitBuffer(tmpBuffer4, this-&gt;tileLength * sizeof(DTYPE_X));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void Process()&#123; //操作流水</span><br><span class="line">        int32_t loopCount = TILE_NUM * BUFFER_NUM;</span><br><span class="line">        for(int32_t i = 0;i &lt; loopCount;i ++)&#123;</span><br><span class="line">            CopyIn(i);</span><br><span class="line">            Compute(i);</span><br><span class="line">            CopyOut(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    __aicore__ inline void CopyIn(int32_t progress)&#123; //数据拷入操作</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; xLocal = inQueueX.AllocTensor&lt;DTYPE_X&gt;();</span><br><span class="line">        DataCopy(xLocal, xGm[progress * this-&gt;tileLength], this-&gt;tileLength);</span><br><span class="line">        inQueueX. EnQue(xLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void Compute(int32_t progress)&#123; //核心计算部分，算法实现在这完成</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; xLocal = inQueueX.DeQue&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_Z&gt; zLocal = outQueueZ.AllocTensor&lt;DTYPE_Z&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor1 = tmpBuffer1.Get&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor2 = tmpBuffer2.Get&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor3 = tmpBuffer3.Get&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor4 = tmpBuffer4.Get&lt;DTYPE_X&gt;();</span><br><span class="line">        DTYPE_X inputVal1 = -1;</span><br><span class="line">        DTYPE_X inputVal2 = 0.5;</span><br><span class="line">        Muls(tmpTensor1, xLocal, inputVal1, this-&gt;tileLength);     //这里求出-x</span><br><span class="line">        Exp(tmpTensor2, tmpTensor1, this-&gt;tileLength);             //这里用tmpTensor2存求出的e^-x</span><br><span class="line">        Exp(tmpTensor3, xLocal, this-&gt;tileLength);                 //这里用tmpTensor3存求出的e^x</span><br><span class="line">        Sub(tmpTensor4, tmpTensor3, tmpTensor2, this-&gt;tileLength); //这里用tmpTensor4存3-2得到e^x-e^-x</span><br><span class="line">        Muls(zLocal, tmpTensor4, inputVal2, this-&gt;tileLength);     //这里乘1/2并存到zLocal中</span><br><span class="line">        outQueueZ.EnQue&lt;DTYPE_Z&gt;(zLocal);</span><br><span class="line">        inQueueX.FreeTensor(xLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    __aicore__ inline void CopyOut(int32_t progress)&#123; //数据拷出</span><br><span class="line">        LocalTensor&lt;DTYPE_Z&gt; zLocal = outQueueZ.DeQue&lt;DTYPE_Z&gt;();</span><br><span class="line">        DataCopy(zGm[progress * this-&gt;tileLength], zLocal, this-&gt;tileLength);</span><br><span class="line">        outQueueZ.FreeTensor(zLocal);</span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    //一些类对象的初始化</span><br><span class="line">    TPipe pipe;                    </span><br><span class="line">    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;</span><br><span class="line">    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueZ;</span><br><span class="line">    GlobalTensor&lt;half&gt; xGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; zGm;</span><br><span class="line">    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;</span><br><span class="line">    uint32_t blockLength;</span><br><span class="line">    uint32_t tileNum;</span><br><span class="line">    uint32_t tileLength;</span><br><span class="line">&#125;;</span><br><span class="line">extern &quot;C&quot; __global__ __aicore__ void sinh_custom(GM_ADDR x, GM_ADDR z, GM_ADDR workspace, GM_ADDR tiling) &#123;</span><br><span class="line">    //核函数的定义，函数的接口</span><br><span class="line">    GET_TILING_DATA(tiling_data, tiling);</span><br><span class="line">    KernelSinh op;</span><br><span class="line">    op.Init(x,z,tiling_data.totalLength,tiling_data.tileNum);</span><br><span class="line">    op.Process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是host侧的文件<br>sinh_custom.cpp的修改：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;sinh_custom_tiling.h&quot;</span><br><span class="line">#include &quot;register/op_def_registry.h&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace optiling &#123;</span><br><span class="line">static ge::graphStatus TilingFunc(gert::TilingContext* context)</span><br><span class="line">&#123;</span><br><span class="line">  //这里是最核心的部分，定义一些类的对象，完成数据赋值，这里也是范式编程</span><br><span class="line">  SinhCustomTilingData tiling;</span><br><span class="line">  const uint32_t BLOCK_DIM = 8;</span><br><span class="line">  const uint32_t TILE_NUM = 8;</span><br><span class="line">  uint32_t totalLength = context-&gt;GetInputShape(0)-&gt;GetOriginShape().GetShapeSize();</span><br><span class="line">  context-&gt;SetBlockDim(BLOCK_DIM);</span><br><span class="line">  tiling.set_totalLength(totalLength);</span><br><span class="line">  tiling.set_tileNum(TILE_NUM);</span><br><span class="line">  tiling.SaveToBuffer(context-&gt;GetRawTilingData()-&gt;GetData(), </span><br><span class="line">  context-&gt;GetRawTilingData()-&gt;GetCapacity());</span><br><span class="line">  context-&gt;GetRawTilingData()-&gt;SetDataSize(tiling.GetDataSize());</span><br><span class="line">  size_t *currentWorkspace = context-&gt;GetWorkspaceSizes(1);</span><br><span class="line">  currentWorkspace[0] = 0;</span><br><span class="line">  return ge::GRAPH_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace ge &#123;</span><br><span class="line">static ge::graphStatus InferShape(gert::InferShapeContext* context)</span><br><span class="line">&#123;</span><br><span class="line">    const gert::Shape* x1_shape = context-&gt;GetInputShape(0);</span><br><span class="line">    gert::Shape* y_shape = context-&gt;GetOutputShape(0);</span><br><span class="line">    *y_shape = *x1_shape;</span><br><span class="line">    return GRAPH_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">namespace ops &#123;</span><br><span class="line">class SinhCustom : public OpDef &#123;</span><br><span class="line">public:</span><br><span class="line">    //这里是自动生成的，表明数据的输入输出的类型还有具体有哪些输入输出</span><br><span class="line">    explicit SinhCustom(const char* name) : OpDef(name)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;Input(&quot;x&quot;)</span><br><span class="line">            .ParamType(REQUIRED)</span><br><span class="line">            .DataType(&#123;ge::DT_FLOAT16&#125;)</span><br><span class="line">            .Format(&#123;ge::FORMAT_ND&#125;)</span><br><span class="line">            .UnknownShapeFormat(&#123;ge::FORMAT_ND&#125;);</span><br><span class="line">        this-&gt;Output(&quot;z&quot;)</span><br><span class="line">            .ParamType(REQUIRED)</span><br><span class="line">            .DataType(&#123;ge::DT_FLOAT16&#125;)</span><br><span class="line">            .Format(&#123;ge::FORMAT_ND&#125;)</span><br><span class="line">            .UnknownShapeFormat(&#123;ge::FORMAT_ND&#125;);</span><br><span class="line"></span><br><span class="line">        this-&gt;SetInferShape(ge::InferShape);</span><br><span class="line"></span><br><span class="line">        this-&gt;AICore()</span><br><span class="line">            .SetTiling(optiling::TilingFunc);</span><br><span class="line">        this-&gt;AICore().AddConfig(&quot;ascend310b&quot;); //具体放在什么处理器上运行</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">OP_ADD(SinhCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sinh_custom_tilling.h文件：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">//这里主要就是定义一下头文件</span><br><span class="line">#ifndef Sinh_CUSTOM_TILING_H</span><br><span class="line">#define Sinh_CUSTOM_TILING_H</span><br><span class="line">#include &quot;register/tilingdata_base.h&quot;</span><br><span class="line"></span><br><span class="line">namespace optiling &#123;</span><br><span class="line">BEGIN_TILING_DATA_DEF(SinhCustomTilingData)</span><br><span class="line">  //增加类对象，也是范式编程</span><br><span class="line">  TILING_DATA_FIELD_DEF(uint32_t, size);</span><br><span class="line">  TILING_DATA_FIELD_DEF(uint32_t,tileNum);</span><br><span class="line">  TILING_DATA_FIELD_DEF(uint32_t,totalNum);</span><br><span class="line">  TILING_DATA_FIELD_DEF(uint32_t,totalLength);</span><br><span class="line">END_TILING_DATA_DEF;</span><br><span class="line"></span><br><span class="line">REGISTER_TILING_DATA_CLASS(SinhCustom, SinhCustomTilingData)</span><br><span class="line">&#125;</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>AscendC算子中级认证</title>
      <link href="/2024/10/20/AscendC%E7%AE%97%E5%AD%90/"/>
      <url>/2024/10/20/AscendC%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>AscendC算子原生支持C和C++标准规范,主要运行在Ascend系列产品上。因为是直接运行在npu上的算子函数，所以涉及到比较多的内存处理，包括一些数据搬移，内存管理，队列管理，还是比较的繁琐，但好在官方提供了编程范式，只需要按照所给的框架就能完成算子的实现。<br>开发者主要做的就是确定任务，设计算子，实现计算功能。<br>明确矢量算子的输入以及输出。Ascend C提供的矢量计算接口的操作元素都为LocalTensor，输入数据需要先搬运进AI Core的内部存储Local Memory，然后使用自定义Compute函数计算接口完成，得到最终结果，再搬出到外部存储Global Memory上。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">#include &quot;kernel_operator.h&quot;</span><br><span class="line">using namespace AscendC;</span><br><span class="line"></span><br><span class="line">constexpr int32_t TOTAL_LENGTH = 8 * 2048;                            // total length of data</span><br><span class="line">constexpr int32_t USE_CORE_NUM = 8;                                   // num of core used</span><br><span class="line">constexpr int32_t BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         // length computed of each core</span><br><span class="line">constexpr int32_t TILE_NUM = 8;                                       // split data into 8 tiles for each core</span><br><span class="line">constexpr int32_t BUFFER_NUM = 2;                                     // tensor num for each queue</span><br><span class="line">constexpr int32_t TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; // seperate to 2 parts, due to double buffer</span><br><span class="line"></span><br><span class="line">class KernelAdd &#123;</span><br><span class="line">public:</span><br><span class="line">__aicore__ inline KernelAdd() &#123;&#125;</span><br><span class="line">__aicore__ inline void Init(GM_ADDR x, GM_ADDR y, GM_ADDR z) //初始化输入输出</span><br><span class="line">&#123;</span><br><span class="line">xGm.SetGlobalBuffer((__gm__ half *)x + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">yGm.SetGlobalBuffer((__gm__ half *)y + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">zGm.SetGlobalBuffer((__gm__ half *)z + BLOCK_LENGTH * GetBlockIdx(), BLOCK_LENGTH);</span><br><span class="line">pipe.InitBuffer(inQueueX, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">pipe.InitBuffer(inQueueY, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">pipe.InitBuffer(outQueueZ, BUFFER_NUM, TILE_LENGTH * sizeof(half));</span><br><span class="line">&#125;</span><br><span class="line">__aicore__ inline void Process() //实现流水操作</span><br><span class="line">&#123;</span><br><span class="line">int32_t loopCount = TILE_NUM * BUFFER_NUM;</span><br><span class="line">for (int32_t i = 0; i &lt; loopCount; i++) &#123;</span><br><span class="line">CopyIn(i);</span><br><span class="line">Compute(i);</span><br><span class="line">CopyOut(i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">__aicore__ inline void CopyIn(int32_t progress) //数据拷贝，入队</span><br><span class="line">&#123;</span><br><span class="line">LocalTensor&lt;half&gt; xLocal = inQueueX.AllocTensor&lt;half&gt;();</span><br><span class="line">LocalTensor&lt;half&gt; yLocal = inQueueY.AllocTensor&lt;half&gt;();</span><br><span class="line">DataCopy(xLocal, xGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">DataCopy(yLocal, yGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">inQueueX.EnQue(xLocal);</span><br><span class="line">inQueueY.EnQue(yLocal);</span><br><span class="line">&#125;</span><br><span class="line">__aicore__ inline void Compute(int32_t progress) //核心计算过程，算法实现最核心的部分</span><br><span class="line">&#123;</span><br><span class="line">LocalTensor&lt;half&gt; xLocal = inQueueX.DeQue&lt;half&gt;(); //这两个LocalTensor就是实际函数的输入值，通过一系列数据搬移到了这，开始计算</span><br><span class="line">LocalTensor&lt;half&gt; yLocal = inQueueY.DeQue&lt;half&gt;();</span><br><span class="line">LocalTensor&lt;half&gt; zLocal = outQueueZ.AllocTensor&lt;half&gt;(); //初始化输出对象，等下准备丢进输出队列</span><br><span class="line">Add(zLocal, xLocal, yLocal, TILE_LENGTH);</span><br><span class="line">outQueueZ.EnQue&lt;half&gt;(zLocal); //在这里丢进输出队列</span><br><span class="line">inQueueX.FreeTensor(xLocal); //释放空间</span><br><span class="line">inQueueY.FreeTensor(yLocal);</span><br><span class="line">&#125;</span><br><span class="line">__aicore__ inline void CopyOut(int32_t progress) //数据搬出</span><br><span class="line">&#123;</span><br><span class="line">LocalTensor&lt;half&gt; zLocal = outQueueZ.DeQue&lt;half&gt;();</span><br><span class="line">DataCopy(zGm[progress * TILE_LENGTH], zLocal, TILE_LENGTH);</span><br><span class="line">outQueueZ.FreeTensor(zLocal);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">TPipe pipe;</span><br><span class="line">TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX, inQueueY;</span><br><span class="line">TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueZ;</span><br><span class="line">GlobalTensor&lt;half&gt; xGm;</span><br><span class="line">GlobalTensor&lt;half&gt; yGm;</span><br><span class="line">GlobalTensor&lt;half&gt; zGm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">extern &quot;C&quot; __global__ __aicore__ void add_custom(GM_ADDR x, GM_ADDR y, GM_ADDR z) //核函数，作为整个功能的接口</span><br><span class="line">&#123;</span><br><span class="line">KernelAdd op;</span><br><span class="line">op.Init(x, y, z);</span><br><span class="line">op.Process();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Ascend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于yolov5的羽毛球轨迹识别</title>
      <link href="/2024/10/18/yolov5/"/>
      <url>/2024/10/18/yolov5/</url>
      
        <content type="html"><![CDATA[<p>yolov5是一种很流行的目标检测系统，基于这套系统，我们可以很轻松的开发各种识别物体的项目，不过需要自己准备数据集，以及一定的计算资源。<br>本质上来说，yolov5也是一个基于深度学习的视觉识别系统，效果很不错，就省去了自己开发的过程。同时还可以在源代码上修改，来实现自己的需求。<br>首先从部署yolov5开始：<br>部署的环境是基于python的，为了方便管理，我们使用anaconda创建一个新的虚拟环境，以便跟别的环境隔离开，这样就不会冲突。<br>在命令行中输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5 python=3.10</span><br></pre></td></tr></table></figure><br>然后再输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure><br>这样就创建好并且进入了一个新的环境内。接下来克隆官方仓库并且安装依赖项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5</span><br><span class="line">cd yolov5</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><br>如果有N卡的话还得下载对应的cuda<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure><br>到这里yolov5的环境就配置好了。随便跑点样例实验一下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --device 0</span><br></pre></td></tr></table></figure><br>这就是一个最简单的训练的代码，使用的是官方的数据集，训练后的模型存储在 runs/train/exp/weights/best.pt<br>尝试用模型检测一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect.py --device 0</span><br></pre></td></tr></table></figure><br>检测的结果会在 runs/detect/exp中<br>上面是一些比较简单的配置还有验证的过程，接下来的是最重要的，想要对一个物体进行识别，首先得有数据集，然后基于这个数据集进行训练，因为网上实在没有羽毛球的模型，我就自己框了大概1500张图，分割三分之一作为验证集，剩下的作为训练集。框图可以用这个<a href="http://makesense.bimant.com/">网站</a><br>框图之后会得到一份标签集，可以使用下面的代码分割训练集验证集<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import shutil</span><br><span class="line"></span><br><span class="line">image_folder = &#x27;path/to/images&#x27;  # 图片文件夹路径</span><br><span class="line">label_folder = &#x27;path/to/labels&#x27;  # 标签文件夹路径</span><br><span class="line"></span><br><span class="line">val_image_folder = &#x27;path/to/val_images&#x27;  # 验证集图片存放路径</span><br><span class="line">val_label_folder = &#x27;path/to/val_labels&#x27;  # 验证集标签存放路径</span><br><span class="line"></span><br><span class="line">os.makedirs(val_image_folder, exist_ok=True)</span><br><span class="line">os.makedirs(val_label_folder, exist_ok=True)</span><br><span class="line"></span><br><span class="line">image_files = sorted(os.listdir(image_folder))</span><br><span class="line">label_files = sorted(os.listdir(label_folder))</span><br><span class="line"></span><br><span class="line">if len(image_files) != len(label_files):</span><br><span class="line">raise ValueError(&quot;图片和标签数量不匹配！请检查文件夹内容。&quot;)</span><br><span class="line"></span><br><span class="line">for i, image_file in enumerate(image_files):</span><br><span class="line">if (i + 1) % 3 == 0:  # 每三张图片选一张</span><br><span class="line"># 获取对应的标签文件名</span><br><span class="line">label_file = label_files[i]</span><br><span class="line"></span><br><span class="line">        image_path = os.path.join(image_folder, image_file)</span><br><span class="line">        label_path = os.path.join(label_folder, label_file)</span><br><span class="line">        </span><br><span class="line">        shutil.move(image_path, os.path.join(val_image_folder, image_file))</span><br><span class="line">        shutil.move(label_path, os.path.join(val_label_folder, label_file))</span><br><span class="line">        </span><br><span class="line">print(&quot;验证集划分完成！&quot;)</span><br></pre></td></tr></table></figure><br>然后再对分割好的数据集去训练<br>下面是基于项目需求，对代码的修改<br>首先添加一个元组，并且生成一个背景，用于绘制我们的轨迹<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_centers = []</span><br><span class="line">canvas = np.ones((im0s.shape[0], im0s.shape[1], 3), dtype=np.uint8) * 255</span><br></pre></td></tr></table></figure><br>用来存储我们识别到的羽毛球在空间中的坐标<br>然后在识别到目标之后，把原代码的框选修改为点<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x_center = (xyxy[0] + xyxy[2]) / 2</span><br><span class="line">y_center = (xyxy[1] + xyxy[3]) / 2</span><br><span class="line">#LOGGER.info(&quot;x_center: %f, y_center: %f&quot;, x_center, y_center)</span><br><span class="line">all_centers.append((x_center, y_center))</span><br><span class="line">radius = 10</span><br><span class="line">color = (0, 0, 255)</span><br><span class="line">cv2.circle(imc, (int(x_center), int(y_center)), radius, color, thickness=-1)</span><br></pre></td></tr></table></figure><br>然后再遍历我们的坐标，将点绘制在背景上<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for x_center , y_center in all_centers:</span><br><span class="line">    cv2.circle(canvas, (int(x_center), int(y_center)), 10, (0, 0, 255), -1)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">save_path = increment_path(Path(project) / name, exist_ok=exist_ok)</span><br><span class="line">save_path.mkdir(parents=True, exist_ok=True)</span><br><span class="line">final_save_path = save_path / &quot;all_centers.jpg&quot;</span><br><span class="line">cv2.imwrite(str(final_save_path), canvas)</span><br></pre></td></tr></table></figure><br>然后就可以得到羽毛球的轨迹啦<br>其实最开始是打算做类似鹰眼的轨迹识别加预测，但是预测的过程太过于复杂，折腾了一堆东西没有什么进展就over了</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，FM0编解码代码</title>
      <link href="/2024/10/17/FM0/"/>
      <url>/2024/10/17/FM0/</url>
      
        <content type="html"><![CDATA[<p>使用matlab编写的一份用于编解码信号的.m文件<br>密勒码解码过程可以表述为：以 2 倍的数据时钟码读入，进行每两位转换一次，01 和 10 都转换为 1，00 和 11 都转换为 0，这样即完成解码得到原始 NRZ 码，本实验无起始同步和停止过程<br>本代码参照密勒码的文件修改<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">x = [1 0 1 1 0 0 0 1];</span><br><span class="line">FM0 = zeros(1, 2 * length(x));</span><br><span class="line">state = 0;</span><br><span class="line"></span><br><span class="line">for i = 1:length(x)</span><br><span class="line">    if x(i) == 1</span><br><span class="line">        FM0(2*i-1) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">        FM0(2*i) = state;</span><br><span class="line">    else</span><br><span class="line">        FM0(2*i-1) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">        FM0(2*i) = ~state;</span><br><span class="line">        state = ~state;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 1);</span><br><span class="line">stairs(0:length(x)-1, x, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;原始数据&#x27;);</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 2);</span><br><span class="line">stairs(0:length(FM0)-1, FM0, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;FM0 编码结果&#x27;);</span><br><span class="line"></span><br><span class="line">decoded_data = zeros(1, length(FM0) / 2);</span><br><span class="line"></span><br><span class="line">for i = 1:2:length(FM0)-2</span><br><span class="line">    if (FM0(i) ~= FM0(i+1)) &amp;&amp; (FM0(i+1) == FM0(i+2))</span><br><span class="line">        decoded_data((i+1)/2) = 1;</span><br><span class="line">    else</span><br><span class="line">        decoded_data((i+1)/2) = 0;</span><br><span class="line">    end</span><br><span class="line">end</span><br><span class="line"></span><br><span class="line">subplot(2, 1, 1);</span><br><span class="line">stairs(0:length(decoded_data)-1, decoded_data, &#x27;r&#x27;);</span><br><span class="line">title(&#x27;FM0 解码结果&#x27;);</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随便写点</title>
      <link href="/2024/10/15/start/"/>
      <url>/2024/10/15/start/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客! 如果感兴趣的话就多逛逛。不定期更新项目的经历，记录自己走过的路。这是我的<a href="https://github.com/xxxkkw">代码仓库</a>。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
