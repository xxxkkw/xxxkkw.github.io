<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>鹰眼项目重构</title>
      <link href="/2025/02/19/EagleEyes/"/>
      <url>/2025/02/19/EagleEyes/</url>
      
        <content type="html"><![CDATA[<h1 id="羽毛球轨迹预测系统-Badminton-Trajectory-Prediction"><a href="#羽毛球轨迹预测系统-Badminton-Trajectory-Prediction" class="headerlink" title="羽毛球轨迹预测系统 (Badminton Trajectory Prediction)"></a>羽毛球轨迹预测系统 (Badminton Trajectory Prediction)</h1><p>基于YOLOv5目标检测与LSTM时序建模的羽毛球运动轨迹预测系统(重构版)</p><h2 id="🚀-功能特性"><a href="#🚀-功能特性" class="headerlink" title="🚀 功能特性"></a>🚀 功能特性</h2><ul><li><strong>高精度检测</strong>: 采用YOLOv5实时检测羽毛球位置</li><li><strong>轨迹建模</strong>: 使用深度LSTM网络学习运动模式</li><li><strong>可视化分析</strong>: 生成轨迹对比图与训练曲线</li><li><strong>多步预测</strong>: 支持任意长度的轨迹预测</li></ul><h2 id="📦-环境要求"><a href="#📦-环境要求" class="headerlink" title="📦 环境要求"></a>📦 环境要求</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/ultralytics/yolov5</span><br><span class="line"><span class="built_in">cd</span> yolov5</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><h2 id="🗂-项目结构"><a href="#🗂-项目结构" class="headerlink" title="🗂 项目结构"></a>🗂 项目结构</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">EagleEyes/</span><br><span class="line">├── input_videos/          # 原始视频存储目录</span><br><span class="line">├── trajectories/          # 提取的轨迹CSV文件</span><br><span class="line">├── saved_models/          # 训练好的模型参数</span><br><span class="line">├── prediction_results/    # 预测结果可视化</span><br><span class="line">├── extract.py             # 轨迹提取脚本</span><br><span class="line">├── train.py               # LSTM训练脚本</span><br><span class="line">└── predict.py             # 预测与可视化脚本</span><br></pre></td></tr></table></figure><h2 id="🛠-使用指南"><a href="#🛠-使用指南" class="headerlink" title="🛠 使用指南"></a>🛠 使用指南</h2><ol><li><p>轨迹提取</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python extract.py \</span><br><span class="line">    --video_dir input_videos \</span><br><span class="line">    --output_dir trajectories \</span><br><span class="line">    --visualize </span><br></pre></td></tr></table></figure></li><li><p>模型训练</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">python train.py \</span><br><span class="line">    --data_dir ./trajectories \</span><br><span class="line">    --save_dir ./saved_models \</span><br><span class="line">    --epochs 500 \</span><br><span class="line">    --batch_size 64</span><br></pre></td></tr></table></figure></li><li><p>轨迹预测</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">python predict.py \</span><br><span class="line">    --model_path ./saved_models/model_epoch500.pt \</span><br><span class="line">    --trajectory_file ./trajectories/test1.csv \</span><br><span class="line">    --output_dir ./prediction_results</span><br></pre></td></tr></table></figure><h2 id="⚙-参数说明"><a href="#⚙-参数说明" class="headerlink" title="⚙ 参数说明"></a>⚙ 参数说明</h2><h3 id="训练参数-train-py"><a href="#训练参数-train-py" class="headerlink" title="训练参数 (train.py)"></a>训练参数 (train.py)</h3><p>| 参数名         | 默认值 | 说明               |<br>|————————|————|——————————|<br>| —seq_len      | 30     | 输入序列长度（帧数） |<br>| —pred_steps   | 10     | 预测步长            |<br>| —hidden_size  | 128    | LSTM隐藏层维度      |<br>| —num_layers   | 3      | LSTM堆叠层数        |</p><h3 id="预测参数-predict-py"><a href="#预测参数-predict-py" class="headerlink" title="预测参数 (predict.py)"></a>预测参数 (predict.py)</h3><p>| 参数名           | 默认值 | 说明               |<br>|—————————|————|——————————|<br>| —observed_ratio | 0.3    | 输入观测比例         |<br>| —predict_steps  | 10     | 预测帧数            |<br>| —line_width     | 2      | 可视化线条粗细      |</p><h2 id="📊-结果示例"><a href="#📊-结果示例" class="headerlink" title="📊 结果示例"></a>📊 结果示例</h2></li></ol><h3 id="轨迹对比图"><a href="#轨迹对比图" class="headerlink" title="轨迹对比图"></a>轨迹对比图</h3><p><img src="path_to_image" alt="prediction"></p><ul><li><strong>蓝色实线</strong>: 实际观测轨迹</li><li><strong>红色虚线</strong>: 模型预测轨迹<h3 id="训练曲线"><a href="#训练曲线" class="headerlink" title="训练曲线"></a>训练曲线</h3></li></ul><p><img src="path_to_image" alt="training_curves"></p><ul><li>左: 训练损失下降曲线</li><li>右: 测试集相对误差</li></ul>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AtlasChatR1项目</title>
      <link href="/2025/02/02/AtlasChatR1/"/>
      <url>/2025/02/02/AtlasChatR1/</url>
      
        <content type="html"><![CDATA[<h1 id="DeepSeek-R1-1-5B-模型在昇腾-Atlas-200I-DK-A2-上的推理项目"><a href="#DeepSeek-R1-1-5B-模型在昇腾-Atlas-200I-DK-A2-上的推理项目" class="headerlink" title="DeepSeek R1 1.5B 模型在昇腾 Atlas 200I DK A2 上的推理项目"></a>DeepSeek R1 1.5B 模型在昇腾 Atlas 200I DK A2 上的推理项目</h1><p>项目基于 DeepSeek 最新的 R1 1.5B 模型，在昇腾 Atlas 200I DK A2 设备上进行推理，并使用 int8 量化,并将模型转换为 OM 模型以便在板上运行。以下是项目的详细说明和使用指南。</p><hr><h2 id="项目简介"><a href="#项目简介" class="headerlink" title="项目简介"></a>项目简介</h2><p>本项目旨在将 DeepSeek R1 1.5B 模型部署到昇腾 Atlas 200I DK A2 设备上，通过 int8 量化优化模型推理性能。项目包含以下主要功能：</p><ol><li><strong>模型导出</strong>：将 DeepSeek R1 1.5B 模型导出为 ONNX 格式。</li><li><strong>模型量化</strong>：将 ONNX 模型量化为 int8 格式。</li><li><strong>模型推理与测评</strong>：在 Atlas 200I DK A2 设备上运行推理，并测评模型的推理速度和显存占用。</li></ol><hr><h2 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h2><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DeepSeek-Atlas-Chat/</span><br><span class="line">├── export.py # 将 DeepSeek R1 模型导出为 ONNX 格式</span><br><span class="line">├── quant.py # 将 ONNX 模型量化为 int8 格式</span><br><span class="line">├── eval.py # 测评模型推理速度和显存占用</span><br><span class="line">├── onnx_model_output/ # 存放从原始 R1 模型导出的 ONNX 模型</span><br><span class="line">├── deepseek_quant8.onnx # 自动生成的 int8 量化后的 ONNX 模型</span><br><span class="line">└── README.md # 项目说明文档</span><br></pre></td></tr></table></figure></h2><h2 id="环境要求"><a href="#环境要求" class="headerlink" title="环境要求"></a>环境要求</h2><ul><li><strong>硬件</strong>：昇腾 Atlas 200I DK A2，理论上也可以在其他310B设备运行</li><li><strong>软件</strong>：<ul><li>Python 3.9 或更高版本</li><li>ONNX 1.10.0 或更高版本</li><li>昇腾 CANN 工具包（推荐版本 8.0.0RC3）</li><li>PyTorch 2.0.0 及以上</li><li>ONNX Runtime（可选，用于本地测试）</li></ul></li></ul><hr><h2 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h2><h3 id="1-请先自行下载DeepSeek-R1-Distill-Qwen-1-5B模型"><a href="#1-请先自行下载DeepSeek-R1-Distill-Qwen-1-5B模型" class="headerlink" title="1. 请先自行下载DeepSeek-R1-Distill-Qwen-1.5B模型"></a>1. 请先自行下载DeepSeek-R1-Distill-Qwen-1.5B模型</h3><h3 id="2-导出-ONNX-模型"><a href="#2-导出-ONNX-模型" class="headerlink" title="2. 导出 ONNX 模型"></a>2. 导出 ONNX 模型</h3><p>运行 <code>export.py</code> 脚本，将 DeepSeek R1 1.5B 模型导出为 ONNX 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python export.py -m /path/to/DeepSeek-R1-Distill-Qwen-1.5B</span><br></pre></td></tr></table></figure><p>若设备支持cuda或者mps，可在运行时加上<code>-d cuda</code>或者<code>-d mps</code></p><h3 id="3-量化-ONNX-模型为-int8-格式"><a href="#3-量化-ONNX-模型为-int8-格式" class="headerlink" title="3. 量化 ONNX 模型为 int8 格式"></a>3. 量化 ONNX 模型为 int8 格式</h3><p>运行 quant.py 脚本，将 ONNX 模型量化为 int8 格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python quant.py</span><br></pre></td></tr></table></figure><p>量化后的模型将保存为 <code>deepseek_quant8.onnx</code></p><h3 id="4-测评模型推理性能"><a href="#4-测评模型推理性能" class="headerlink" title="4. 测评模型推理性能"></a>4. 测评模型推理性能</h3><p>运行 eval.py 脚本，测评模型在 转换量化前后的推理速度：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python eval.py</span><br></pre></td></tr></table></figure><br>得到结果大致如下，设备性能不同可能得到不同的结果，结果符合从fp32到int8的性能提升<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试 PyTorch 模型...</span><br><span class="line">PyTorch 模型平均推理时间: 0.2651 秒</span><br><span class="line">PyTorch 模型每秒处理 token 数量: 37.72 tokens/s</span><br><span class="line"></span><br><span class="line">测试 ONNX 模型...</span><br><span class="line">ONNX 模型平均推理时间: 0.0611 秒</span><br><span class="line">ONNX 模型每秒处理 token 数量: 163.77 tokens/s</span><br><span class="line"></span><br><span class="line">ONNX 模型相较于 PyTorch 模型推理速度提升: 4.34 倍</span><br></pre></td></tr></table></figure></p><h3 id="5-部署算子"><a href="#5-部署算子" class="headerlink" title="5. 部署算子"></a>5. 部署算子</h3><p>因为<code>cann</code>的算子清单中没有<code>MatMulIntegar</code>,<code>DynamicQuantizeLinear</code>,<code>DequantizeLinear</code>算子，所以就需要自己将算子补上，否则atc工具无法转换成om模型，后续的推理也无法正常运行<br>首先安装<code>protoc</code>，这是算子部署build.sh需要的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 安装protoc==1.13.0, 找一空闲目录下载</span></span><br><span class="line">wget  https://obs-9be7.obs.cn-east-2.myhuaweicloud.com/wanzutao/tiny-llama/protobuf-all-3.13.0.tar.gz</span><br><span class="line">tar -zxvf protobuf-all-3.13.0.tar.gz</span><br><span class="line"><span class="built_in">cd</span> protobuf-3.13.0</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install autoconf automake libtool</span><br><span class="line">./autogen.sh</span><br><span class="line">./configure</span><br><span class="line">make -j4</span><br><span class="line">make install</span><br><span class="line"><span class="built_in">sudo</span> ldconfig</span><br><span class="line">protoc --version <span class="comment"># 查看版本号</span></span><br></pre></td></tr></table></figure></p><p>随后部署算子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> matmul_integer_plugin.cc /usr/local/Ascend/ascend-toolkit/latest/tools/msopgen/template/custom_operator_sample/DSL/Onnx/framework/onnx_plugin/</span><br><span class="line"><span class="built_in">cp</span> dynamic_quantize_linear_plugin.cc /usr/local/Ascend/ascend-toolkit/latest/tools/msopgen/template/custom_operator_sample/DSL/Onnx/framework/onnx_plugin/</span><br><span class="line"><span class="built_in">cp</span> dequantize_linear_plugin.cc /usr/local/Ascend/ascend-toolkit/latest/tools/msopgen/template/custom_operator_sample/DSL/Onnx/framework/onnx_plugin/</span><br><span class="line"><span class="built_in">cd</span> /usr/local/Ascend/ascend-toolkit/latest/tools/msopgen/template/custom_operator_sample/DSL/Onnx </span><br></pre></td></tr></table></figure><br>打开<code>build.sh</code>，添加如下四个环境变量<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> ASCEND_TENSOR_COMPILER_INCLUDE=/usr/local/Ascend/ascend-toolkit/latest/include</span><br><span class="line"><span class="built_in">export</span> TOOLCHAIN_DIR=/usr</span><br><span class="line"><span class="built_in">export</span> AICPU_KERNEL_TARGET=cust_aicpu_kernels</span><br><span class="line"><span class="built_in">export</span> AICPU_SOC_VERSION=Ascend310B4</span><br></pre></td></tr></table></figure><br>编译部署算子<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">./build.sh </span><br><span class="line"><span class="built_in">cd</span> build_out/</span><br><span class="line">./custom_opp_ubuntu_aarch64.run</span><br></pre></td></tr></table></figure></p><h3 id="6-转换-ONNX-模型为-OM-模型"><a href="#6-转换-ONNX-模型为-OM-模型" class="headerlink" title="6. 转换 ONNX 模型为 OM 模型"></a>6. 转换 ONNX 模型为 OM 模型</h3><p>使用昇腾 ATC 工具将量化后的 ONNX 模型转换为 OM 模型：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">atc --model=/root/AtlasChatR1/modified_model.onnx \</span><br><span class="line">    --framework=5 \</span><br><span class="line">    --output=deepseek_om_model \</span><br><span class="line">    --input_format=ND \</span><br><span class="line">    --input_shape=<span class="string">&quot;input_ids:-1,-1;attention_mask:-1,-1&quot;</span> \</span><br><span class="line">    --dynamic_dims=<span class="string">&quot;1,64,1,64;8,128,8,128;16,256,16,256&quot;</span> \</span><br><span class="line">    --soc_version=Ascend310B4 \</span><br><span class="line">    --precision_mode=allow_fp32_to_fp16</span><br></pre></td></tr></table></figure><br>这一步的时间会很长，耐心等待</p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>AI-Mario项目</title>
      <link href="/2024/12/23/AI-Mario/"/>
      <url>/2024/12/23/AI-Mario/</url>
      
        <content type="html"><![CDATA[<h1 id="超级马里奥-DQN-智能体"><a href="#超级马里奥-DQN-智能体" class="headerlink" title="超级马里奥 DQN 智能体"></a>超级马里奥 DQN 智能体</h1><p>该项目实现了一个使用 <strong>DQN</strong> 的智能体来玩 <strong>超级马里奥</strong>。智能体通过强化学习来最大化奖励，并学习在环境中采取最优动作。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><ul><li><strong>Gym Super Mario Bros 环境</strong>：使用 gym-super-mario-bros 库创建马里奥环境。</li><li><strong>DQN</strong>：使用 PyTorch 实现 DQN 训练智能体。</li><li><strong>经验回放缓冲区</strong>：存储和采样游戏状态以稳定训练过程。</li><li><strong>目标网络（Target Network）</strong>：使用单独的目标网络来提高训练的稳定性。</li><li><strong>Epsilon-贪婪策略</strong>：在训练过程中平衡探索与利用。<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2></li></ul><ol><li>克隆本仓库：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/xxxkkw/AI-Mario.git</span><br></pre></td></tr></table></figure></li><li>安装所需的依赖：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure>注：这里一定严格按照环境内的版本，要不然有bug<h3 id="文件结构"><a href="#文件结构" class="headerlink" title="文件结构"></a>文件结构</h3></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">├── models/                 <span class="comment"># 保存的模型将存储在这里</span></span><br><span class="line">├── train.py                <span class="comment"># 主要训练脚本</span></span><br><span class="line">├── agent.py                <span class="comment"># DQN 智能体实现</span></span><br><span class="line">├── run.py                  <span class="comment"># 测试游戏</span></span><br><span class="line">├── replay_buffer.py        <span class="comment"># 经验回放缓冲区</span></span><br><span class="line">├── config.py               <span class="comment"># 超参数配置文件</span></span><br><span class="line">├── init_env.py             <span class="comment"># 马里奥环境设置和包装</span></span><br><span class="line">├── requirements.txt        <span class="comment"># Python 依赖库</span></span><br><span class="line">├── final_model1-1.dat      <span class="comment"># 模型文件</span></span><br><span class="line">├── final_model1-2.dat      <span class="comment"># 模型文件</span></span><br><span class="line">└── README.md               <span class="comment"># 项目文档</span></span><br></pre></td></tr></table></figure><ol><li>使用前必读：<br>项目内置已经训练好的一个模型，可以使用<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py</span><br></pre></td></tr></table></figure>来尝试玩一下已经训练好的模型。如果你想自己从头开始训练模型，只需要<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py</span><br></pre></td></tr></table></figure>这样就能从头开始训练属于你的模型了.想玩别的关卡或者训练别的关卡，只需在命令行中输入时添加—level参数即可<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --level 1-1</span><br></pre></td></tr></table></figure>或者已经把某个模型训练到了一半，想继续训练，只需<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --model path_to_your_model</span><br></pre></td></tr></table></figure>此外，项目内置两个关卡的模型，1-1以及1-2，可以体验一下<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python run.py --level 1-2</span><br></pre></td></tr></table></figure>玩的开心！</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，CRC代码</title>
      <link href="/2024/11/28/CRC/"/>
      <url>/2024/11/28/CRC/</url>
      
        <content type="html"><![CDATA[<p>代码实现了CRC（循环冗余校验）编码和解码的过程，应用于RFID实验中。在通信系统中，CRC是一种常用的错误检测技术，能够帮助检测传输数据中的误码。代码首先定义了消息比特和生成多项式，然后进行多项式除法来计算CRC校验码，并将其附加到原始消息比特中，生成编码后的帧。随后通过模拟接收到的码字进行CRC解码，检测接收数据是否存在误码。最后，代码通过图形化展示了编码前后的消息比特序列，以及是否存在错误的检测结果。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">clear all</span><br><span class="line">L = <span class="number">16</span>;                       <span class="comment">%一帧中的消息比特个数</span></span><br><span class="line">poly = [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">1</span>];         <span class="comment">%%此参数代表CRC编码使用的生成多项式，这里是x^4 + x^2 + x + 1</span></span><br><span class="line">N1 = <span class="built_in">length</span>(poly)<span class="number">-1</span>;          <span class="comment">%%此参数代表生成多项式的次数，用于确定消息比特左移的位数</span></span><br><span class="line"><span class="comment">%msg = randi([0 1], 1, L);      %消息比特（这里使用了自定义的消息比特序列代替随机生成）</span></span><br><span class="line">msg = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>];</span><br><span class="line">msg1 = [msg <span class="built_in">zeros</span>(<span class="number">1</span>,N1)];     <span class="comment">%消息比特左移，为后续的除法运算做准备，左移的位数等于生成多项式的次数</span></span><br><span class="line">[q,r]=deconv(msg1,poly);    <span class="comment">%%此过程是进行多项式除法，msg1为被除数（左移后的消息比特序列），poly为除数（生成多项式），q为商，r为余数</span></span><br><span class="line">r = <span class="built_in">mod</span>(<span class="built_in">abs</span>(r),<span class="number">2</span>);            <span class="comment">%%此过程是对余数进行模2运算，确保结果为0或1，符合CRC编码在GF(2)上的运算规则</span></span><br><span class="line">crc = r(L + <span class="number">1</span>:<span class="keyword">end</span>);             <span class="comment">%%此参数代表提取出的CRC校验码，即余数的后N1位</span></span><br><span class="line">frame = [msg crc];            <span class="comment">%%此参数代表构建的编码后的帧，由原始消息比特和CRC校验码组成</span></span><br><span class="line"><span class="comment">% 假设接收到的码字是frame，进行CRC解码</span></span><br><span class="line">rec_frame = frame; </span><br><span class="line">[q1,r1]=deconv([rec_frame <span class="built_in">zeros</span>(<span class="number">1</span>,N1)],poly); </span><br><span class="line">r1 = <span class="built_in">mod</span>(<span class="built_in">abs</span>(r1),<span class="number">2</span>);</span><br><span class="line">msg</span><br><span class="line">frame</span><br><span class="line">r1</span><br><span class="line"><span class="comment">%画图显示</span></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">stem(msg)</span><br><span class="line">title(<span class="string">&#x27;编码器输入信号&#x27;</span>)</span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">stem(frame)</span><br><span class="line">title(<span class="string">&#x27;编码器输出信号&#x27;</span>)</span><br><span class="line"><span class="keyword">if</span>(all(r1(:) == <span class="number">0</span>))     <span class="comment">%</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;接收码字没有错误！&quot;</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">  <span class="built_in">disp</span>(<span class="string">&quot;接收码字中有误码！&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，LinearBlockCode代码</title>
      <link href="/2024/11/28/LinearBlockCode/"/>
      <url>/2024/11/28/LinearBlockCode/</url>
      
        <content type="html"><![CDATA[<p>代码实现了线性分组码（Linear Block Code, LBC）的编码和解码过程，用于RFID实验。线性分组码是一种常见的编码技术，能够帮助检测和纠正传输过程中的误码。</p><h2 id="代码主要流程"><a href="#代码主要流程" class="headerlink" title="代码主要流程"></a>代码主要流程</h2><ol><li><strong>生成矩阵 G</strong>：首先构建生成矩阵 <code>G</code>，用于将原始消息比特映射为编码后的码字。</li><li><strong>编码过程</strong>：定义消息比特矩阵 <code>A</code>，通过矩阵乘法将 <code>A</code> 和生成矩阵 <code>G</code> 相乘，得到编码后的码字 <code>C</code>。</li><li><strong>校验矩阵 H</strong>：通过辅助函数 <code>gen2par</code>，利用生成矩阵 <code>G</code> 生成校验矩阵 <code>H</code>，用于错误检测。</li><li><strong>译码过程</strong>：输入接收到的7位码字，通过与校验矩阵 <code>H</code> 计算综合矢量 <code>S</code>，定位出错误比特位置，并修正错误，输出正确的码字。</li></ol><p>代码不仅实现了编码和译码，还包括错误检测与纠错功能，是RFID通信实验的重要部分。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">gen2par_example</span><span class="params">()</span></span></span><br><span class="line">    clear all;</span><br><span class="line">    G1 = <span class="built_in">eye</span>(<span class="number">4</span>);</span><br><span class="line">    G2 = [<span class="number">1</span> <span class="number">1</span> <span class="number">1</span>;</span><br><span class="line">          <span class="number">1</span> <span class="number">1</span> <span class="number">0</span>;</span><br><span class="line">          <span class="number">1</span> <span class="number">0</span> <span class="number">1</span>;</span><br><span class="line">          <span class="number">0</span> <span class="number">1</span> <span class="number">1</span>];</span><br><span class="line">    G = [G1,G2];</span><br><span class="line">    fprintf(<span class="string">&#x27;生成矩阵为：G= \n&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(G);</span><br><span class="line">    A = [<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>;<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>;<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>;];</span><br><span class="line">    fprintf(<span class="string">&#x27;原码为：A= \n&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(A);</span><br><span class="line">    C1 = A*G;</span><br><span class="line">    C = <span class="built_in">mod</span>(C1,<span class="number">2</span>);</span><br><span class="line">    fprintf(<span class="string">&#x27;输出的编码为：C= \n&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(C);</span><br><span class="line">    H = gen2par(G);</span><br><span class="line">    fprintf(<span class="string">&#x27;校验矩阵为：H= \n&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(H);</span><br><span class="line">    <span class="comment">%%以下输入接收到的码字，译出原码</span></span><br><span class="line">    Rev = input(<span class="string">&#x27;请输入7位接收码字，用空格隔开：&#x27;</span>,<span class="string">&#x27;s&#x27;</span>);</span><br><span class="line">    Rev = str2num(Rev);</span><br><span class="line">    S1 = Rev*(H&#x27;);</span><br><span class="line">    S = <span class="built_in">mod</span>(S1,<span class="number">2</span>);</span><br><span class="line">    E = [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">7</span>;</span><br><span class="line">        Hi = H(:,[<span class="built_in">i</span>]);</span><br><span class="line">        Sum = S+Hi&#x27;;</span><br><span class="line">        Sum = <span class="built_in">mod</span>(Sum,<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (all(Sum(:)==<span class="number">0</span>));</span><br><span class="line">            fprintf(<span class="string">&#x27;接收码字中错误码位是第：&#x27;</span>);</span><br><span class="line">            <span class="built_in">disp</span>(<span class="built_in">i</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            E(<span class="number">1</span>, <span class="built_in">i</span>)=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">end</span>;</span><br><span class="line">    <span class="keyword">end</span>;</span><br><span class="line">    Cr = <span class="built_in">mod</span>((Rev + E),<span class="number">2</span>);</span><br><span class="line">    fprintf(<span class="string">&#x27;正确接收码字：Cr=&#x27;</span>);</span><br><span class="line">    <span class="built_in">disp</span>(Cr);</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">H</span> = <span class="title">gen2par</span><span class="params">(G)</span></span></span><br><span class="line">    [k,n]=<span class="built_in">size</span>(G);</span><br><span class="line">    P = G(:,k + <span class="number">1</span>:n);</span><br><span class="line">    I = <span class="built_in">eye</span>(n - k);</span><br><span class="line">    H = [P&#x27;,I];</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，Parity代码</title>
      <link href="/2024/11/28/Parity/"/>
      <url>/2024/11/28/Parity/</url>
      
        <content type="html"><![CDATA[<p>代码实现了奇偶校验（Parity Check）在RFID实验中的应用，奇偶校验是一种简单但有效的错误检测方法，能够检测传输数据中的单个比特错误。</p><h2 id="代码主要功能"><a href="#代码主要功能" class="headerlink" title="代码主要功能"></a>代码主要功能</h2><ol><li><strong>输入矩阵大小</strong>：用户通过输入行数和列数，生成一个随机的二进制矩阵 <code>A</code>，代表待校验的数据。</li><li><strong>选择奇偶校验类型</strong>：用户可以选择奇校验或偶校验，程序根据选择为每一行数据生成相应的校验位，并将其附加到矩阵的最后一列。</li><li><strong>校验位计算</strong>：<ul><li><strong>偶校验</strong>：如果行中1的个数为奇数，添加校验位1，使得1的个数变为偶数；如果为偶数，则添加0。</li><li><strong>奇校验</strong>：如果行中1的个数为偶数，添加校验位1，使得1的个数变为奇数；如果为奇数，则添加0。</li></ul></li><li><strong>错误检测</strong>：代码通过手动引入错误，然后再次进行奇偶校验，逐行检查数据是否正确，输出检查结果。</li><li><strong>循环操作</strong>：用户可以多次选择不同的校验类型进行实验，直到选择结束校验（输入9）。</li></ol><p>该代码通过奇偶校验位的计算和检测，演示了如何在数据传输过程中发现错误，是RFID实验中基础的错误检测机制之一。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">clear all;<span class="comment">%清除工作空间的所有变量</span></span><br><span class="line">m = input(<span class="string">&#x27;请输入行:&#x27;</span>);<span class="comment">%input(&#x27; &#x27;);用于向计算机输入一个参数 </span></span><br><span class="line">n = input(<span class="string">&#x27;请输入列:&#x27;</span>);</span><br><span class="line">A = randi([<span class="number">0</span> <span class="number">1</span>],m,n)<span class="comment">%randint(m,n)产生的是一个m*n维的矩阵，矩阵的元素或者是0或者是1，是随机的并显示A</span></span><br><span class="line">B=A;<span class="comment">%A暂存在B，</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    A=B;<span class="comment">%避免循环中A中信码改变</span></span><br><span class="line">    sum = <span class="built_in">zeros</span>(<span class="number">1</span>,m);<span class="comment">%zeros(1,m)创建一个1行m列的零矩阵</span></span><br><span class="line">    l = input(<span class="string">&#x27;请选择奇偶校验(0:偶校验 1:奇校验 9:结束校验):&#x27;</span>);<span class="comment">%;不回显</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span> || l == <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m</span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:n            <span class="comment">%%计算矩阵A中每一行的元素之和，从第1列到第n列</span></span><br><span class="line">                sum(<span class="built_in">i</span>) = sum(<span class="built_in">i</span>) + A(<span class="built_in">i</span>,<span class="built_in">j</span>);<span class="comment">%</span></span><br><span class="line">                x = sum(<span class="built_in">i</span>);<span class="comment">%</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">0</span>             <span class="comment">%%选择偶校验（l == 0）的情况下执行的操作</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">rem</span>(x,<span class="number">2</span>) == <span class="number">1</span> <span class="comment">%</span></span><br><span class="line">                    A(<span class="built_in">i</span>,n+<span class="number">1</span>) = <span class="number">1</span>; <span class="comment">%</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    A(<span class="built_in">i</span>,n+<span class="number">1</span>) = <span class="number">0</span>; <span class="comment">%</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> l == <span class="number">1</span>              <span class="comment">%%选择奇校验（l == 1）的情况下执行的操作</span></span><br><span class="line">                <span class="keyword">if</span> <span class="built_in">rem</span>(x,<span class="number">2</span>) == <span class="number">1</span><span class="comment">%</span></span><br><span class="line">                    A(<span class="built_in">i</span>,n+<span class="number">1</span>) = <span class="number">0</span>;<span class="comment">%</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    A(<span class="built_in">i</span>,n+<span class="number">1</span>) = <span class="number">1</span>;<span class="comment">%</span></span><br><span class="line">                <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span>    </span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> l == <span class="number">9</span></span><br><span class="line">            fprintf(<span class="string">&#x27;退出校验~\n&#x27;</span>);<span class="comment">%设置显示格式 </span></span><br><span class="line">            <span class="keyword">break</span>;<span class="comment">%跳出循环</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            fprintf(<span class="string">&#x27;非法输入！！\n&#x27;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;<span class="comment">%结束本次循环</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    fprintf(<span class="string">&#x27;补校验位：&#x27;</span>)</span><br><span class="line">    A<span class="comment">%显示加入校验位后的矩阵</span></span><br><span class="line">    <span class="comment">%</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">0</span>    </span><br><span class="line">       A(<span class="number">1</span>,<span class="number">2</span>) = ~A(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">        sum = <span class="built_in">zeros</span>(<span class="number">1</span>,m);<span class="comment">%zeros(1,m)创建一个1行m列的零矩阵</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m          <span class="comment">%%检查添加校验位后的矩阵数据的正确性，逐行检查</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n+<span class="number">1</span>)  <span class="comment">%</span></span><br><span class="line">                sum(<span class="built_in">i</span>) = sum(<span class="built_in">i</span>) + A(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">                x = sum(<span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rem</span>(x,<span class="number">2</span>) == <span class="number">0</span>  <span class="comment">%</span></span><br><span class="line">                fprintf(<span class="string">&#x27;第%d行数据正确！\n&#x27;</span>, <span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">else</span>   <span class="comment">%</span></span><br><span class="line">                fprintf(<span class="string">&#x27;第%d行数据有错！\n&#x27;</span>, <span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">if</span> l == <span class="number">1</span> <span class="comment">%</span></span><br><span class="line">      A(<span class="number">3</span>,<span class="number">1</span>)=~A(<span class="number">3</span>,<span class="number">1</span>);</span><br><span class="line">      A</span><br><span class="line">      sum = <span class="built_in">zeros</span>(<span class="number">1</span>,m);<span class="comment">%zeros(1,m)创建一个1行m列的零矩阵</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:m    <span class="comment">%%检查添加校验位后的矩阵数据的正确性，逐行检查</span></span><br><span class="line">            <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:(n+<span class="number">1</span>)  </span><br><span class="line">                sum(<span class="built_in">i</span>) = sum(<span class="built_in">i</span>) + A(<span class="built_in">i</span>,<span class="built_in">j</span>);</span><br><span class="line">                x = sum(<span class="built_in">i</span>);</span><br><span class="line">           <span class="keyword">end</span></span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">rem</span>(x,<span class="number">2</span>) == <span class="number">1</span><span class="comment">%</span></span><br><span class="line">                fprintf(<span class="string">&#x27;第%d行数据正确！\n&#x27;</span>, <span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="comment">%</span></span><br><span class="line">                fprintf(<span class="string">&#x27;第%d行数据有错！\n&#x27;</span>, <span class="built_in">i</span>);</span><br><span class="line">            <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span>                  </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树模板</title>
      <link href="/2024/11/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF/"/>
      <url>/2024/11/22/%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><h2 id="根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）"><a href="#根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）" class="headerlink" title="根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）"></a>根据输入创建无向网。分别用Prim算法和Kruskal算法构建最小生成树。（假设：输入数据的最小生成树唯一。）</h2><h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><pre><code>顶点数nn个顶点边数mm条边信息,格式为：顶点1 顶点2 权值Prim算法的起点v</code></pre><h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><pre><code>输出最小生成树的权值之和</code></pre><p>对两种算法，按树的生长顺序，输出边信息(Kruskal中边顶点按数组序号升序输出)</p><p>题目是标准的Kruskal和Prim的板子，直接往里套就行，关键的是Kruskal和Prim的逻辑。<br>先介绍Kruskal算法。</p><h2 id="kruskal-算法的基本步骤："><a href="#kruskal-算法的基本步骤：" class="headerlink" title="kruskal 算法的基本步骤："></a>kruskal 算法的基本步骤：</h2><h3 id="边的排序："><a href="#边的排序：" class="headerlink" title="边的排序："></a>边的排序：</h3><pre><code>将图中所有的边按权重从小到大排序。</code></pre><h3 id="初始化并查集："><a href="#初始化并查集：" class="headerlink" title="初始化并查集："></a>初始化并查集：</h3><pre><code>使用并查集数据结构来判断两个顶点是否属于同一集合（即是否在同一个连通分量中）。</code></pre><h3 id="逐条检查边："><a href="#逐条检查边：" class="headerlink" title="逐条检查边："></a>逐条检查边：</h3><pre><code>遍历排序后的边，检查该边连接的两个点是否属于不同的连通分量，如果是，则将这条边加入到最小生成树中，合并这两个点成一个连通分量，若这两个点在同一个连通分量中，则加入这条边会形成环，因此跳过这条边。</code></pre><h3 id="停止条件："><a href="#停止条件：" class="headerlink" title="停止条件："></a>停止条件：</h3><pre><code>当加入了 n-1 条边时，最小生成树已经构建完成，其中 n 是图中顶点的数量。</code></pre><h2 id="在代码中的实现是这样的"><a href="#在代码中的实现是这样的" class="headerlink" title="在代码中的实现是这样的"></a>在代码中的实现是这样的</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">int</span> n, m, f[<span class="number">1010</span>], cnt = <span class="number">0</span>, sum = <span class="number">0</span>, won = <span class="number">0</span>;</span><br><span class="line">string s[<span class="number">1010</span>], st;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span> &#123; <span class="comment">// 这里使用结构体存边，便于排序以及存储以及遍历</span></span><br><span class="line">    <span class="type">int</span> u, v, w;</span><br><span class="line">&#125; tree[<span class="number">2010</span>];</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(edge x, edge y)</span> </span>&#123;  <span class="comment">// 重载运算符，在后续的排序里面会用到</span></span><br><span class="line">    <span class="keyword">return</span> x.w &lt; y.w;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 并查集最核心的操作，查询父节点，也就是用于判断是否在同一联通分量里面</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;   <span class="comment">// 如果x不是自己的父节点</span></span><br><span class="line">    <span class="keyword">if</span> (x != f[x])  <span class="comment">// 递归找到x的根节点，并压缩路径</span></span><br><span class="line">        f[x] = <span class="built_in">find</span>(f[x]);  <span class="comment">// 返回x的根节点</span></span><br><span class="line">    <span class="keyword">return</span> f[x];</span><br><span class="line">&#125;</span><br><span class="line">map&lt;string,<span class="type">int</span>&gt; mp; <span class="comment">//映射节点字符串与编号</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">vis</span><span class="params">(n + <span class="number">1</span>, <span class="literal">false</span>)</span></span>; <span class="comment">// 访问标记数组，记录哪些节点已经加入MST</span></span><br><span class="line"><span class="comment">// Lambda表达式，用于定义优先队列的比较规则：比较边的权重，较小的权重具有较高优先级</span></span><br><span class="line"><span class="keyword">auto</span> edgeCmp = [](edge a, edge b) &#123; <span class="keyword">return</span> a.w &gt; b.w; &#125;;</span><br><span class="line"><span class="comment">// 优先队列，存储边，按权重从小到大排列</span></span><br><span class="line">priority_queue&lt;edge, vector&lt;edge&gt;, <span class="keyword">decltype</span>(edgeCmp)&gt; <span class="built_in">pq</span>(edgeCmp);</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">build</span><span class="params">()</span></span>&#123;  <span class="comment">//建图过程</span></span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= n;i ++)&#123;</span><br><span class="line">        cin &gt;&gt; s[i];</span><br><span class="line">        mp[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    cin &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>;i &lt;= m;i ++)&#123;</span><br><span class="line">        string u,v;</span><br><span class="line">        <span class="type">int</span> w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        tree[i].u = mp[u];</span><br><span class="line">        tree[i].v = mp[v];</span><br><span class="line">        tree[i].w = w;</span><br><span class="line">     &#125;</span><br><span class="line">    cin &gt;&gt; st;</span><br><span class="line">    <span class="type">int</span> start = mp[st];</span><br><span class="line">    vis[start] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 将所有与起点相连的边加入优先队列</span></span><br><span class="line">        <span class="keyword">if</span> (tree[i].u == start || tree[i].v == start) &#123;</span><br><span class="line">            pq.<span class="built_in">push</span>(tree[i]);  <span class="comment">// 将起点相连的所有边压入优先队列</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">kruskal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;kruskal:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 初始化并查集，f[i]表示第i个顶点的父节点</span></span><br><span class="line">        f[i] = i;  <span class="comment">// 每个节点的父节点初始化为自己</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(tree + <span class="number">1</span>, tree + m + <span class="number">1</span>, cmp);  <span class="comment">// 对所有的边按权重进行升序排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;  <span class="comment">// 遍历所有的边，选择不形成环的边加入MST</span></span><br><span class="line">        <span class="type">int</span> e1 = <span class="built_in">find</span>(tree[i].u), e2 = <span class="built_in">find</span>(tree[i].v);  <span class="comment">// 找到这条边的两个顶点的根</span></span><br><span class="line">        <span class="keyword">if</span> (e1 != e2) &#123;  <span class="comment">// 如果这两个顶点不在同一个连通分量中</span></span><br><span class="line">            f[e1] = e2;  <span class="comment">// 合并这两个集合</span></span><br><span class="line">            <span class="comment">// 输出这条边</span></span><br><span class="line">            string city1 = s[tree[i].u];</span><br><span class="line">            string city2 = s[tree[i].v];</span><br><span class="line">            <span class="keyword">if</span> (city1 &gt; city2) <span class="built_in">swap</span>(city1, city2);</span><br><span class="line">            cout &lt;&lt; city1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; city2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; tree[i].w &lt;&lt; endl;</span><br><span class="line">            sum += tree[i].w;  <span class="comment">// 累加权重</span></span><br><span class="line">            cnt++;  <span class="comment">// 增加已加入的边数</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cnt == n - <span class="number">1</span>) &#123;</span><br><span class="line">            won = <span class="number">1</span>;  <span class="comment">// 如果已加入 n-1 条边，则完成了MST</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Prim算法步骤"><a href="#Prim算法步骤" class="headerlink" title="Prim算法步骤"></a>Prim算法步骤</h2><h3 id="初始化："><a href="#初始化：" class="headerlink" title="初始化："></a>初始化：</h3><pre><code>vis：这是一个访问标记数组，用来标记哪些顶点已经被加入到MST。它的大小为 n+1，初始值全为 false。edgeCmp：这是一个比较函数，定义了优先队列的排序规则，优先选择权重较小的边。pq：这是一个优先队列，存储边的类型 edge。它按照 edge.w 从小到大排序。</code></pre><h3 id="选择起点："><a href="#选择起点：" class="headerlink" title="选择起点："></a>选择起点：</h3><pre><code>通过 find_idx(st) 找到用户输入的起点在 s[] 中的索引 start。标记起点为已访问：vis[start] = true。遍历所有边，将与起点相连的边压入优先队列 pq。</code></pre><h3 id="循环处理优先队列："><a href="#循环处理优先队列：" class="headerlink" title="循环处理优先队列："></a>循环处理优先队列：</h3><pre><code>从优先队列中不断取出当前权重最小的边 currentEdge。通过 currentEdge.u 和 currentEdge.v 获取这条边的两个顶点。如果 u 和 v 都已经被访问（即它们已经在MST中），则跳过这条边，因为加入这条边会形成环。如果其中一个顶点未被访问，则确定要加入MST的顶点（next），并将它标记为已访问。</code></pre><h3 id="输出："><a href="#输出：" class="headerlink" title="输出："></a>输出：</h3><pre><code>根据字典顺序输出加入MST的边的两个顶点和对应的权重。若 city1 的字典顺序比 city2 大，则交换两者，保证输出时小的顶点在前。</code></pre><h3 id="更新优先队列："><a href="#更新优先队列：" class="headerlink" title="更新优先队列："></a>更新优先队列：</h3><pre><code>遍历所有边，将与刚加入MST的顶点 next 相连且另一端未访问的边加入优先队列。</code></pre><h3 id="继续循环："><a href="#继续循环：" class="headerlink" title="继续循环："></a>继续循环：</h3><pre><code>不断重复从优先队列中取出最小边、加入MST、更新优先队列的过程，直到优先队列为空或者所有顶点都被访问。</code></pre><h2 id="代码实现如下"><a href="#代码实现如下" class="headerlink" title="代码实现如下"></a>代码实现如下</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">prim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;prim:&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123; <span class="comment">// 开始处理优先队列中的边</span></span><br><span class="line">        <span class="comment">// 取出优先队列中权重最小的边</span></span><br><span class="line">        edge currentEdge = pq.<span class="built_in">top</span>();</span><br><span class="line">        pq.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="type">int</span> u = currentEdge.u;  <span class="comment">// 当前边的起点</span></span><br><span class="line">        <span class="type">int</span> v = currentEdge.v;  <span class="comment">// 当前边的终点</span></span><br><span class="line">        <span class="type">int</span> w = currentEdge.w;  <span class="comment">// 当前边的权重</span></span><br><span class="line">        <span class="comment">// 如果u和v都已经在MST中，跳过这条边，因为它会形成环</span></span><br><span class="line">        <span class="keyword">if</span> (vis[u] &amp;&amp; vis[v]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 确定下一个要加入MST的顶点（u或v中尚未访问的那个）</span></span><br><span class="line">        <span class="type">int</span> next = vis[u] ? v : u;</span><br><span class="line">        <span class="comment">// 标记这个顶点为已访问</span></span><br><span class="line">        vis[next] = <span class="literal">true</span>;</span><br><span class="line">        string city1 = s[u];</span><br><span class="line">        string city2 = s[v];</span><br><span class="line">        cout &lt;&lt; city1 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; city2 &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; w &lt;&lt; endl;</span><br><span class="line">        sum += w; <span class="comment">// 将这条边的权重加到总权重上</span></span><br><span class="line">        <span class="comment">// 遍历所有边，将与新加入顶点相连且未访问过的顶点加入优先队列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="comment">// 如果这条边连接的顶点之一是刚加入MST的顶点，且另一端尚未加入MST</span></span><br><span class="line">            <span class="keyword">if</span> ((tree[i].u == next &amp;&amp; !vis[tree[i].v]) ||</span><br><span class="line">                (tree[i].v == next &amp;&amp; !vis[tree[i].u])) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(tree[i]);  <span class="comment">// 将这条边压入优先队列</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树构建与遍历</title>
      <link href="/2024/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/"/>
      <url>/2024/10/21/%E4%BA%8C%E5%8F%89%E6%A0%91%E6%9E%84%E5%BB%BA%E4%B8%8E%E9%81%8D%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<p>给出一颗二叉树的逻辑结构，并且建立该二叉树的二叉链式存储结构，分别输出二叉树的先序，中序，后序遍历<br>构建的整体思路就是依靠递归，分别构建左右子树，不为空就继续往下构建子树，直到结束<br>遍历也是差不多的思路，从根节点开始，不为空就继续向下递归，前中后只是输出的顺序不一样，本质上来说遍历的时候经过都是一样的<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//节点的基本组成，包含本节点数据，左右子树的指针</span></span><br><span class="line">    <span class="type">char</span> data;</span><br><span class="line">    Node *lch;</span><br><span class="line">    Node *rch;</span><br><span class="line">    Node *parent;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="type">char</span> c) : <span class="built_in">data</span>(c), <span class="built_in">lch</span>(<span class="literal">NULL</span>), <span class="built_in">rch</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TREE</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Node* root;</span><br><span class="line">    ll pos;</span><br><span class="line">    string tree_str;</span><br><span class="line">    <span class="built_in">TREE</span>() : <span class="built_in">root</span>(<span class="literal">NULL</span>), <span class="built_in">pos</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">create_tree</span><span class="params">(<span class="type">const</span> string&amp; s)</span> </span>&#123;</span><br><span class="line">        pos = <span class="number">0</span>;</span><br><span class="line">        tree_str = s;</span><br><span class="line">        root = <span class="built_in">create</span>(); <span class="comment">//这里就是从根节点开始往下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Node* <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//递归构建子树</span></span><br><span class="line">        <span class="keyword">if</span>(pos &gt;= tree_str.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">char</span> c = tree_str[pos++];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;#&#x27;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        Node* node = <span class="keyword">new</span> <span class="built_in">Node</span>(c);</span><br><span class="line">        node-&gt;lch = <span class="built_in">create</span>();</span><br><span class="line">        node-&gt;rch = <span class="built_in">create</span>();</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">pre</span><span class="params">(Node* node)</span> </span>&#123; <span class="comment">//先序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        cout &lt;&lt; node-&gt;data;</span><br><span class="line">        <span class="built_in">pre</span>(node-&gt;lch);</span><br><span class="line">        <span class="built_in">pre</span>(node-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">in</span><span class="params">(Node* node)</span> </span>&#123; <span class="comment">//中序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">in</span>(node-&gt;lch);</span><br><span class="line">        cout &lt;&lt; node-&gt;data;</span><br><span class="line">        <span class="built_in">in</span>(node-&gt;rch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">post</span><span class="params">(Node* node)</span> </span>&#123; <span class="comment">//后序遍历</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="built_in">post</span>(node-&gt;lch);</span><br><span class="line">        <span class="built_in">post</span>(node-&gt;rch);</span><br><span class="line">        cout &lt;&lt; node-&gt;data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="built_in">pre</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">in</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">post</span>(root);</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">leaves</span><span class="params">(Node* p)</span> </span>&#123;  <span class="comment">//这里顺便放上遍历叶子节点的函数</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!p-&gt;lch &amp;&amp; !p-&gt;rch)</span><br><span class="line">                cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">leaves</span>(p-&gt;lch);</span><br><span class="line">            <span class="built_in">leaves</span>(p-&gt;rch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Parents</span><span class="params">(Node* p)</span> </span>&#123;  <span class="comment">//遍历父节点</span></span><br><span class="line">        <span class="keyword">if</span> (p) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;lch &amp;&amp; (!p-&gt;lch-&gt;lch &amp;&amp; !p-&gt;lch-&gt;rch))</span><br><span class="line">                cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">Parents</span>(p-&gt;lch);</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;rch &amp;&amp; (!p-&gt;rch-&gt;lch &amp;&amp; !p-&gt;rch-&gt;rch))</span><br><span class="line">                cout &lt;&lt; p-&gt;data &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="built_in">Parents</span>(p-&gt;rch);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span> </span>&#123;</span><br><span class="line">    ll t;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--) &#123;</span><br><span class="line">        string s;</span><br><span class="line">        cin &gt;&gt; s;</span><br><span class="line">        TREE tree;</span><br><span class="line">        tree.<span class="built_in">create_tree</span>(s);</span><br><span class="line">        tree.<span class="built_in">display</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AscendC算子中级认证</title>
      <link href="/2024/10/21/AscendC%E7%AE%97%E5%AD%90%E4%B8%AD%E7%BA%A7%E8%AE%A4%E8%AF%81/"/>
      <url>/2024/10/21/AscendC%E7%AE%97%E5%AD%90%E4%B8%AD%E7%BA%A7%E8%AE%A4%E8%AF%81/</url>
      
        <content type="html"><![CDATA[<p>AscendC算子中级认证的题目是模拟numpy中的sinh算子，编写基于AscendC的算子sinh，命名为sinhCustom，并编写kernel侧代码，host侧代码，使用aclnn算子调用测试<br>sinh的算法实现为： sinh(x) = (exp(x) - exp(-x)) / 2.0<br>首先在kernel侧，修改sinh_custom.cpp文件，完成算子最核心的部分<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel_operator.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AscendC;</span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TOTAL_LENGTH = <span class="number">8</span> * <span class="number">2048</span>;                            <span class="comment">// 数据总长度</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> USE_CORE_NUM = <span class="number">8</span>;                                   <span class="comment">// 使用核心数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         <span class="comment">// 每个核计算的数据长度</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TILE_NUM = <span class="number">8</span>;                                       <span class="comment">// 将数据为每个核心分成8个区块</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> BUFFER_NUM = <span class="number">2</span>;                                     <span class="comment">// 每个队列的张量数量</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; <span class="comment">// 利用双缓冲技术，将某个对象或数据分为两部分处理</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KernelSinh</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="title">KernelSinh</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(GM_ADDR x, GM_ADDR z,<span class="type">uint32_t</span> totalLength,<span class="type">uint32_t</span> tileNum)</span> <span class="comment">//初始化输入输出</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">ASSERT</span>(<span class="built_in">GetBlockNum</span>() != <span class="number">0</span> &amp;&amp; <span class="string">&quot;block dim can not be zero!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;blockLength = totalLength / <span class="built_in">GetBlockNum</span>();</span><br><span class="line">        <span class="keyword">this</span>-&gt;tileNum = tileNum;</span><br><span class="line">        <span class="built_in">ASSERT</span>(tileNum != <span class="number">0</span> &amp;&amp; <span class="string">&quot;tile num can not be zero!&quot;</span>);</span><br><span class="line">        <span class="keyword">this</span>-&gt;tileLength = <span class="keyword">this</span>-&gt;blockLength / tileNum / BUFFER_NUM;</span><br><span class="line"></span><br><span class="line">        xGm.<span class="built_in">SetGlobalBuffer</span>((__gm__ DTYPE_X *)x + <span class="keyword">this</span>-&gt;blockLength * <span class="built_in">GetBlockIdx</span>(),<span class="keyword">this</span>-&gt;blockLength);</span><br><span class="line">        zGm.<span class="built_in">SetGlobalBuffer</span>((__gm__ DTYPE_Z *)z + <span class="keyword">this</span>-&gt;blockLength * <span class="built_in">GetBlockIdx</span>(),<span class="keyword">this</span>-&gt;blockLength);</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(inQueueX, BUFFER_NUM, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_X)); <span class="comment">//初始化内存</span></span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(outQueueZ, BUFFER_NUM, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_Z));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(tmpBuffer1, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_X));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(tmpBuffer2, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_X));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(tmpBuffer3, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_X));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(tmpBuffer4, <span class="keyword">this</span>-&gt;tileLength * <span class="built_in">sizeof</span>(DTYPE_X));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Process</span><span class="params">()</span></span>&#123; <span class="comment">//操作流水</span></span><br><span class="line">        <span class="type">int32_t</span> loopCount = TILE_NUM * BUFFER_NUM;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int32_t</span> i = <span class="number">0</span>;i &lt; loopCount;i ++)&#123;</span><br><span class="line">            <span class="built_in">CopyIn</span>(i);</span><br><span class="line">            <span class="built_in">Compute</span>(i);</span><br><span class="line">            <span class="built_in">CopyOut</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">CopyIn</span><span class="params">(<span class="type">int32_t</span> progress)</span></span>&#123; <span class="comment">//数据拷入操作</span></span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; xLocal = inQueueX.<span class="built_in">AllocTensor</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        <span class="built_in">DataCopy</span>(xLocal, xGm[progress * <span class="keyword">this</span>-&gt;tileLength], <span class="keyword">this</span>-&gt;tileLength);</span><br><span class="line">        inQueueX. <span class="built_in">EnQue</span>(xLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Compute</span><span class="params">(<span class="type">int32_t</span> progress)</span></span>&#123; <span class="comment">//核心计算部分，算法实现在这完成</span></span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; xLocal = inQueueX.<span class="built_in">DeQue</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_Z&gt; zLocal = outQueueZ.<span class="built_in">AllocTensor</span>&lt;DTYPE_Z&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor1 = tmpBuffer<span class="number">1.</span><span class="built_in">Get</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor2 = tmpBuffer<span class="number">2.</span><span class="built_in">Get</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor3 = tmpBuffer<span class="number">3.</span><span class="built_in">Get</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        LocalTensor&lt;DTYPE_X&gt; tmpTensor4 = tmpBuffer<span class="number">4.</span><span class="built_in">Get</span>&lt;DTYPE_X&gt;();</span><br><span class="line">        DTYPE_X inputVal1 = <span class="number">-1</span>;</span><br><span class="line">        DTYPE_X inputVal2 = <span class="number">0.5</span>;</span><br><span class="line">        <span class="built_in">Muls</span>(tmpTensor1, xLocal, inputVal1, <span class="keyword">this</span>-&gt;tileLength);     <span class="comment">//这里求出-x</span></span><br><span class="line">        <span class="built_in">Exp</span>(tmpTensor2, tmpTensor1, <span class="keyword">this</span>-&gt;tileLength);             <span class="comment">//这里用tmpTensor2存求出的e^-x</span></span><br><span class="line">        <span class="built_in">Exp</span>(tmpTensor3, xLocal, <span class="keyword">this</span>-&gt;tileLength);                 <span class="comment">//这里用tmpTensor3存求出的e^x</span></span><br><span class="line">        <span class="built_in">Sub</span>(tmpTensor4, tmpTensor3, tmpTensor2, <span class="keyword">this</span>-&gt;tileLength); <span class="comment">//这里用tmpTensor4存3-2得到e^x-e^-x</span></span><br><span class="line">        <span class="built_in">Muls</span>(zLocal, tmpTensor4, inputVal2, <span class="keyword">this</span>-&gt;tileLength);     <span class="comment">//这里乘1/2并存到zLocal中</span></span><br><span class="line">        outQueueZ.<span class="built_in">EnQue</span>&lt;DTYPE_Z&gt;(zLocal);</span><br><span class="line">        inQueueX.<span class="built_in">FreeTensor</span>(xLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">CopyOut</span><span class="params">(<span class="type">int32_t</span> progress)</span></span>&#123; <span class="comment">//数据拷出</span></span><br><span class="line">        LocalTensor&lt;DTYPE_Z&gt; zLocal = outQueueZ.<span class="built_in">DeQue</span>&lt;DTYPE_Z&gt;();</span><br><span class="line">        <span class="built_in">DataCopy</span>(zGm[progress * <span class="keyword">this</span>-&gt;tileLength], zLocal, <span class="keyword">this</span>-&gt;tileLength);</span><br><span class="line">        outQueueZ.<span class="built_in">FreeTensor</span>(zLocal);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">//一些类对象的初始化</span></span><br><span class="line">    TPipe pipe;                    </span><br><span class="line">    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX;</span><br><span class="line">    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueZ;</span><br><span class="line">    GlobalTensor&lt;half&gt; xGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; zGm;</span><br><span class="line">    TBuf&lt;QuePosition::VECCALC&gt; tmpBuffer1, tmpBuffer2, tmpBuffer3, tmpBuffer4;</span><br><span class="line">    <span class="type">uint32_t</span> blockLength;</span><br><span class="line">    <span class="type">uint32_t</span> tileNum;</span><br><span class="line">    <span class="type">uint32_t</span> tileLength;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">__global__ __aicore__ <span class="type">void</span> <span class="title">sinh_custom</span><span class="params">(GM_ADDR x, GM_ADDR z, GM_ADDR workspace, GM_ADDR tiling)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//核函数的定义，函数的接口</span></span><br><span class="line">    <span class="built_in">GET_TILING_DATA</span>(tiling_data, tiling);</span><br><span class="line">    KernelSinh op;</span><br><span class="line">    op.<span class="built_in">Init</span>(x,z,tiling_data.totalLength,tiling_data.tileNum);</span><br><span class="line">    op.<span class="built_in">Process</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>接下来是host侧的文件<br>sinh_custom.cpp的修改：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sinh_custom_tiling.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;register/op_def_registry.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> optiling &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> ge::graphStatus <span class="title">TilingFunc</span><span class="params">(gert::TilingContext* context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//这里是最核心的部分，定义一些类的对象，完成数据赋值，这里也是范式编程</span></span><br><span class="line">  SinhCustomTilingData tiling;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> BLOCK_DIM = <span class="number">8</span>;</span><br><span class="line">  <span class="type">const</span> <span class="type">uint32_t</span> TILE_NUM = <span class="number">8</span>;</span><br><span class="line">  <span class="type">uint32_t</span> totalLength = context-&gt;<span class="built_in">GetInputShape</span>(<span class="number">0</span>)-&gt;<span class="built_in">GetOriginShape</span>().<span class="built_in">GetShapeSize</span>();</span><br><span class="line">  context-&gt;<span class="built_in">SetBlockDim</span>(BLOCK_DIM);</span><br><span class="line">  tiling.<span class="built_in">set_totalLength</span>(totalLength);</span><br><span class="line">  tiling.<span class="built_in">set_tileNum</span>(TILE_NUM);</span><br><span class="line">  tiling.<span class="built_in">SaveToBuffer</span>(context-&gt;<span class="built_in">GetRawTilingData</span>()-&gt;<span class="built_in">GetData</span>(), </span><br><span class="line">  context-&gt;<span class="built_in">GetRawTilingData</span>()-&gt;<span class="built_in">GetCapacity</span>());</span><br><span class="line">  context-&gt;<span class="built_in">GetRawTilingData</span>()-&gt;<span class="built_in">SetDataSize</span>(tiling.<span class="built_in">GetDataSize</span>());</span><br><span class="line">  <span class="type">size_t</span> *currentWorkspace = context-&gt;<span class="built_in">GetWorkspaceSizes</span>(<span class="number">1</span>);</span><br><span class="line">  currentWorkspace[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ge::GRAPH_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ge &#123;</span><br><span class="line"><span class="function"><span class="type">static</span> ge::graphStatus <span class="title">InferShape</span><span class="params">(gert::InferShapeContext* context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> gert::Shape* x1_shape = context-&gt;<span class="built_in">GetInputShape</span>(<span class="number">0</span>);</span><br><span class="line">    gert::Shape* y_shape = context-&gt;<span class="built_in">GetOutputShape</span>(<span class="number">0</span>);</span><br><span class="line">    *y_shape = *x1_shape;</span><br><span class="line">    <span class="keyword">return</span> GRAPH_SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> ops &#123;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SinhCustom</span> : <span class="keyword">public</span> OpDef &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//这里是自动生成的，表明数据的输入输出的类型还有具体有哪些输入输出</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">SinhCustom</span><span class="params">(<span class="type">const</span> <span class="type">char</span>* name)</span> : OpDef(name)</span></span><br><span class="line"><span class="function">    &#123;</span></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Input</span>(<span class="string">&quot;x&quot;</span>)</span><br><span class="line">            .<span class="built_in">ParamType</span>(REQUIRED)</span><br><span class="line">            .<span class="built_in">DataType</span>(&#123;ge::DT_FLOAT16&#125;)</span><br><span class="line">            .<span class="built_in">Format</span>(&#123;ge::FORMAT_ND&#125;)</span><br><span class="line">            .<span class="built_in">UnknownShapeFormat</span>(&#123;ge::FORMAT_ND&#125;);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">Output</span>(<span class="string">&quot;z&quot;</span>)</span><br><span class="line">            .<span class="built_in">ParamType</span>(REQUIRED)</span><br><span class="line">            .<span class="built_in">DataType</span>(&#123;ge::DT_FLOAT16&#125;)</span><br><span class="line">            .<span class="built_in">Format</span>(&#123;ge::FORMAT_ND&#125;)</span><br><span class="line">            .<span class="built_in">UnknownShapeFormat</span>(&#123;ge::FORMAT_ND&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">SetInferShape</span>(ge::InferShape);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">AICore</span>()</span><br><span class="line">            .<span class="built_in">SetTiling</span>(optiling::TilingFunc);</span><br><span class="line">        <span class="keyword">this</span>-&gt;<span class="built_in">AICore</span>().<span class="built_in">AddConfig</span>(<span class="string">&quot;ascend310b&quot;</span>); <span class="comment">//具体放在什么处理器上运行</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">OP_ADD</span>(SinhCustom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sinh_custom_tilling.h文件：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里主要就是定义一下头文件</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> Sinh_CUSTOM_TILING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> Sinh_CUSTOM_TILING_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;register/tilingdata_base.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> optiling &#123;</span><br><span class="line"><span class="built_in">BEGIN_TILING_DATA_DEF</span>(SinhCustomTilingData)</span><br><span class="line">  <span class="comment">//增加类对象，也是范式编程</span></span><br><span class="line">  <span class="built_in">TILING_DATA_FIELD_DEF</span>(<span class="type">uint32_t</span>, size);</span><br><span class="line">  <span class="built_in">TILING_DATA_FIELD_DEF</span>(<span class="type">uint32_t</span>,tileNum);</span><br><span class="line">  <span class="built_in">TILING_DATA_FIELD_DEF</span>(<span class="type">uint32_t</span>,totalNum);</span><br><span class="line">  <span class="built_in">TILING_DATA_FIELD_DEF</span>(<span class="type">uint32_t</span>,totalLength);</span><br><span class="line">END_TILING_DATA_DEF;</span><br><span class="line"></span><br><span class="line"><span class="built_in">REGISTER_TILING_DATA_CLASS</span>(SinhCustom, SinhCustomTilingData)</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Ascend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AscendC算子</title>
      <link href="/2024/10/20/AscendC%E7%AE%97%E5%AD%90/"/>
      <url>/2024/10/20/AscendC%E7%AE%97%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>AscendC算子原生支持C和C++标准规范,主要运行在Ascend系列产品上。因为是直接运行在npu上的算子函数，所以涉及到比较多的内存处理，包括一些数据搬移，内存管理，队列管理，还是比较的繁琐，但好在官方提供了编程范式，只需要按照所给的框架就能完成算子的实现。<br>开发者主要做的就是确定任务，设计算子，实现计算功能。<br>明确矢量算子的输入以及输出。Ascend C提供的矢量计算接口的操作元素都为LocalTensor，输入数据需要先搬运进AI Core的内部存储Local Memory，然后使用自定义Compute函数计算接口完成，得到最终结果，再搬出到外部存储Global Memory上。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;kernel_operator.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> AscendC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TOTAL_LENGTH = <span class="number">8</span> * <span class="number">2048</span>;                            <span class="comment">// total length of data</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> USE_CORE_NUM = <span class="number">8</span>;                                   <span class="comment">// num of core used</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> BLOCK_LENGTH = TOTAL_LENGTH / USE_CORE_NUM;         <span class="comment">// length computed of each core</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TILE_NUM = <span class="number">8</span>;                                       <span class="comment">// split data into 8 tiles for each core</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> BUFFER_NUM = <span class="number">2</span>;                                     <span class="comment">// tensor num for each queue</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="type">int32_t</span> TILE_LENGTH = BLOCK_LENGTH / TILE_NUM / BUFFER_NUM; <span class="comment">// seperate to 2 parts, due to double buffer</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">KernelAdd</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="title">KernelAdd</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Init</span><span class="params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> <span class="comment">//初始化输入输出</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        xGm.<span class="built_in">SetGlobalBuffer</span>((__gm__ half *)x + BLOCK_LENGTH * <span class="built_in">GetBlockIdx</span>(), BLOCK_LENGTH);</span><br><span class="line">        yGm.<span class="built_in">SetGlobalBuffer</span>((__gm__ half *)y + BLOCK_LENGTH * <span class="built_in">GetBlockIdx</span>(), BLOCK_LENGTH);</span><br><span class="line">        zGm.<span class="built_in">SetGlobalBuffer</span>((__gm__ half *)z + BLOCK_LENGTH * <span class="built_in">GetBlockIdx</span>(), BLOCK_LENGTH);</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(inQueueX, BUFFER_NUM, TILE_LENGTH * <span class="built_in">sizeof</span>(half));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(inQueueY, BUFFER_NUM, TILE_LENGTH * <span class="built_in">sizeof</span>(half));</span><br><span class="line">        pipe.<span class="built_in">InitBuffer</span>(outQueueZ, BUFFER_NUM, TILE_LENGTH * <span class="built_in">sizeof</span>(half));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Process</span><span class="params">()</span> <span class="comment">//实现流水操作</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int32_t</span> loopCount = TILE_NUM * BUFFER_NUM;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int32_t</span> i = <span class="number">0</span>; i &lt; loopCount; i++) &#123;</span><br><span class="line">            <span class="built_in">CopyIn</span>(i);</span><br><span class="line">            <span class="built_in">Compute</span>(i);</span><br><span class="line">            <span class="built_in">CopyOut</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">CopyIn</span><span class="params">(<span class="type">int32_t</span> progress)</span> <span class="comment">//数据拷贝，入队</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LocalTensor&lt;half&gt; xLocal = inQueueX.<span class="built_in">AllocTensor</span>&lt;half&gt;();</span><br><span class="line">        LocalTensor&lt;half&gt; yLocal = inQueueY.<span class="built_in">AllocTensor</span>&lt;half&gt;();</span><br><span class="line">        <span class="built_in">DataCopy</span>(xLocal, xGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">        <span class="built_in">DataCopy</span>(yLocal, yGm[progress * TILE_LENGTH], TILE_LENGTH);</span><br><span class="line">        inQueueX.<span class="built_in">EnQue</span>(xLocal);</span><br><span class="line">        inQueueY.<span class="built_in">EnQue</span>(yLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">Compute</span><span class="params">(<span class="type">int32_t</span> progress)</span> <span class="comment">//核心计算过程，算法实现最核心的部分</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LocalTensor&lt;half&gt; xLocal = inQueueX.<span class="built_in">DeQue</span>&lt;half&gt;(); <span class="comment">//这两个LocalTensor就是实际函数的输入值，通过一系列数据搬移到了这，开始计算</span></span><br><span class="line">        LocalTensor&lt;half&gt; yLocal = inQueueY.<span class="built_in">DeQue</span>&lt;half&gt;();</span><br><span class="line">        LocalTensor&lt;half&gt; zLocal = outQueueZ.<span class="built_in">AllocTensor</span>&lt;half&gt;(); <span class="comment">//初始化输出对象，等下准备丢进输出队列</span></span><br><span class="line">        <span class="built_in">Add</span>(zLocal, xLocal, yLocal, TILE_LENGTH);</span><br><span class="line">        outQueueZ.<span class="built_in">EnQue</span>&lt;half&gt;(zLocal); <span class="comment">//在这里丢进输出队列</span></span><br><span class="line">        inQueueX.<span class="built_in">FreeTensor</span>(xLocal); <span class="comment">//释放空间</span></span><br><span class="line">        inQueueY.<span class="built_in">FreeTensor</span>(yLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">__aicore__ <span class="keyword">inline</span> <span class="type">void</span> <span class="title">CopyOut</span><span class="params">(<span class="type">int32_t</span> progress)</span> <span class="comment">//数据搬出</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        LocalTensor&lt;half&gt; zLocal = outQueueZ.<span class="built_in">DeQue</span>&lt;half&gt;();</span><br><span class="line">        <span class="built_in">DataCopy</span>(zGm[progress * TILE_LENGTH], zLocal, TILE_LENGTH);</span><br><span class="line">        outQueueZ.<span class="built_in">FreeTensor</span>(zLocal);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    TPipe pipe;</span><br><span class="line">    TQue&lt;QuePosition::VECIN, BUFFER_NUM&gt; inQueueX, inQueueY;</span><br><span class="line">    TQue&lt;QuePosition::VECOUT, BUFFER_NUM&gt; outQueueZ;</span><br><span class="line">    GlobalTensor&lt;half&gt; xGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; yGm;</span><br><span class="line">    GlobalTensor&lt;half&gt; zGm;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">&quot;C&quot;</span> <span class="function">__global__ __aicore__ <span class="type">void</span> <span class="title">add_custom</span><span class="params">(GM_ADDR x, GM_ADDR y, GM_ADDR z)</span> <span class="comment">//核函数，作为整个功能的接口</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    KernelAdd op;</span><br><span class="line">    op.<span class="built_in">Init</span>(x, y, z);</span><br><span class="line">    op.<span class="built_in">Process</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 项目 </tag>
            
            <tag> Ascend </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于yolov5的羽毛球轨迹识别</title>
      <link href="/2024/10/18/yolov5/"/>
      <url>/2024/10/18/yolov5/</url>
      
        <content type="html"><![CDATA[<p>yolov5是一种很流行的目标检测系统，基于这套系统，我们可以很轻松的开发各种识别物体的项目，不过需要自己准备数据集，以及一定的计算资源。<br>本质上来说，yolov5也是一个基于深度学习的视觉识别系统，效果很不错，就省去了自己开发的过程。同时还可以在源代码上修改，来实现自己的需求。<br>首先从部署yolov5开始：<br>部署的环境是基于python的，为了方便管理，我们使用anaconda创建一个新的虚拟环境，以便跟别的环境隔离开，这样就不会冲突。<br>在命令行中输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda create -n yolov5 python=3.10</span><br></pre></td></tr></table></figure><br>然后再输入<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">conda activate yolov5</span><br></pre></td></tr></table></figure><br>这样就创建好并且进入了一个新的环境内。接下来克隆官方仓库并且安装依赖项<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/ultralytics/yolov5</span><br><span class="line">cd yolov5</span><br><span class="line">pip install -r requirements.txt</span><br></pre></td></tr></table></figure><br>如果有N卡的话还得下载对应的cuda<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu113</span><br></pre></td></tr></table></figure><br>到这里yolov5的环境就配置好了。随便跑点样例实验一下。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python train.py --device 0</span><br></pre></td></tr></table></figure><br>这就是一个最简单的训练的代码，使用的是官方的数据集，训练后的模型存储在 runs/train/exp/weights/best.pt<br>尝试用模型检测一下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python detect.py --device 0</span><br></pre></td></tr></table></figure><br>检测的结果会在 runs/detect/exp中<br>上面是一些比较简单的配置还有验证的过程，接下来的是最重要的，想要对一个物体进行识别，首先得有数据集，然后基于这个数据集进行训练，因为网上实在没有羽毛球的模型，我就自己框了大概1500张图，分割三分之一作为验证集，剩下的作为训练集。框图可以用这个<a href="http://makesense.bimant.com/">网站</a><br>框图之后会得到一份标签集，可以使用下面的代码分割训练集验证集<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line">image_folder = <span class="string">&#x27;path/to/images&#x27;</span>  <span class="comment"># 图片文件夹路径</span></span><br><span class="line">label_folder = <span class="string">&#x27;path/to/labels&#x27;</span>  <span class="comment"># 标签文件夹路径</span></span><br><span class="line"></span><br><span class="line">val_image_folder = <span class="string">&#x27;path/to/val_images&#x27;</span>  <span class="comment"># 验证集图片存放路径</span></span><br><span class="line">val_label_folder = <span class="string">&#x27;path/to/val_labels&#x27;</span>  <span class="comment"># 验证集标签存放路径</span></span><br><span class="line"></span><br><span class="line">os.makedirs(val_image_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line">os.makedirs(val_label_folder, exist_ok=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line">image_files = <span class="built_in">sorted</span>(os.listdir(image_folder))</span><br><span class="line">label_files = <span class="built_in">sorted</span>(os.listdir(label_folder))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(image_files) != <span class="built_in">len</span>(label_files):</span><br><span class="line"><span class="keyword">raise</span> ValueError(<span class="string">&quot;图片和标签数量不匹配！请检查文件夹内容。&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i, image_file <span class="keyword">in</span> <span class="built_in">enumerate</span>(image_files):</span><br><span class="line"><span class="keyword">if</span> (i + <span class="number">1</span>) % <span class="number">3</span> == <span class="number">0</span>:  <span class="comment"># 每三张图片选一张</span></span><br><span class="line"><span class="comment"># 获取对应的标签文件名</span></span><br><span class="line">label_file = label_files[i]</span><br><span class="line"></span><br><span class="line">        image_path = os.path.join(image_folder, image_file)</span><br><span class="line">        label_path = os.path.join(label_folder, label_file)</span><br><span class="line">        </span><br><span class="line">        shutil.move(image_path, os.path.join(val_image_folder, image_file))</span><br><span class="line">        shutil.move(label_path, os.path.join(val_label_folder, label_file))</span><br><span class="line">        </span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;验证集划分完成！&quot;</span>)</span><br></pre></td></tr></table></figure><br>然后再对分割好的数据集去训练<br>下面是基于项目需求，对代码的修改<br>首先添加一个元组，并且生成一个背景，用于绘制我们的轨迹<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">all_centers = []</span><br><span class="line">canvas = np.ones((im0s.shape[<span class="number">0</span>], im0s.shape[<span class="number">1</span>], <span class="number">3</span>), dtype=np.uint8) * <span class="number">255</span></span><br></pre></td></tr></table></figure><br>用来存储我们识别到的羽毛球在空间中的坐标<br>然后在识别到目标之后，把原代码的框选修改为点<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">x_center = (xyxy[<span class="number">0</span>] + xyxy[<span class="number">2</span>]) / <span class="number">2</span></span><br><span class="line">y_center = (xyxy[<span class="number">1</span>] + xyxy[<span class="number">3</span>]) / <span class="number">2</span></span><br><span class="line"><span class="comment">#LOGGER.info(&quot;x_center: %f, y_center: %f&quot;, x_center, y_center)</span></span><br><span class="line">all_centers.append((x_center, y_center))</span><br><span class="line">radius = <span class="number">10</span></span><br><span class="line">color = (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>)</span><br><span class="line">cv2.circle(imc, (<span class="built_in">int</span>(x_center), <span class="built_in">int</span>(y_center)), radius, color, thickness=-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><br>然后再遍历我们的坐标，将点绘制在背景上<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x_center , y_center <span class="keyword">in</span> all_centers:</span><br><span class="line">    cv2.circle(canvas, (<span class="built_in">int</span>(x_center), <span class="built_in">int</span>(y_center)), <span class="number">10</span>, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>), -<span class="number">1</span>)</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">save_path = increment_path(Path(project) / name, exist_ok=exist_ok)</span><br><span class="line">save_path.mkdir(parents=<span class="literal">True</span>, exist_ok=<span class="literal">True</span>)</span><br><span class="line">final_save_path = save_path / <span class="string">&quot;all_centers.jpg&quot;</span></span><br><span class="line">cv2.imwrite(<span class="built_in">str</span>(final_save_path), canvas)</span><br></pre></td></tr></table></figure><br>然后就可以得到羽毛球的轨迹啦<br>其实最开始是打算做类似鹰眼的轨迹识别加预测，但是预测的过程太过于复杂，折腾了一堆东西没有什么进展就over了</p>]]></content>
      
      
      <categories>
          
          <category> 项目 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>RFID实验，FM0编解码代码</title>
      <link href="/2024/10/17/FM0/"/>
      <url>/2024/10/17/FM0/</url>
      
        <content type="html"><![CDATA[<p>使用matlab编写的一份用于编解码信号的.m文件<br>密勒码解码过程可以表述为：以 2 倍的数据时钟码读入，进行每两位转换一次，01 和 10 都转换为 1，00 和 11 都转换为 0，这样即完成解码得到原始 NRZ 码，本实验无起始同步和停止过程<br>本代码参照密勒码的文件修改<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">1</span> <span class="number">0</span> <span class="number">1</span> <span class="number">1</span> <span class="number">0</span> <span class="number">0</span> <span class="number">0</span> <span class="number">1</span>]; <span class="comment">% 输入的二进制数据</span></span><br><span class="line">FM0 = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="number">2</span> * <span class="built_in">length</span>(x)); <span class="comment">% 生成FM0编码,对应两个编码位</span></span><br><span class="line">state = <span class="number">0</span>; <span class="comment">% 初始化状态，初始为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">% 对输入数据进行FM0编码</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="built_in">length</span>(x)</span><br><span class="line">    <span class="keyword">if</span> x(<span class="built_in">i</span>) == <span class="number">1</span></span><br><span class="line">        FM0(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>) = ~state; <span class="comment">% 当当前数据位为1时，第一个码元是当前状态的反转</span></span><br><span class="line">        state = ~state; <span class="comment">% 状态翻转</span></span><br><span class="line">        FM0(<span class="number">2</span>*<span class="built_in">i</span>) = state; <span class="comment">% 第二个码元是翻转后的状态</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        FM0(<span class="number">2</span>*<span class="built_in">i</span><span class="number">-1</span>) = ~state; <span class="comment">% 当当前数据位为0时，第一个码元是当前状态的反转</span></span><br><span class="line">        state = ~state; <span class="comment">% 状态翻转</span></span><br><span class="line">        FM0(<span class="number">2</span>*<span class="built_in">i</span>) = ~state; <span class="comment">% 第二个码元是翻转后的状态的反转</span></span><br><span class="line">        state = ~state; <span class="comment">% 再次翻转状态以保持为下一位做准备</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">% 绘制原始输入数据</span></span><br><span class="line">stairs(<span class="number">0</span>:<span class="built_in">length</span>(x)<span class="number">-1</span>, x, <span class="string">&#x27;r&#x27;</span>); <span class="comment">% 使用阶梯图显示输入数据</span></span><br><span class="line">title(<span class="string">&#x27;原始数据&#x27;</span>); <span class="comment">% 设置标题为&quot;原始数据&quot;</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">% 绘制编码后的FM0结果</span></span><br><span class="line">stairs(<span class="number">0</span>:<span class="built_in">length</span>(FM0)<span class="number">-1</span>, FM0, <span class="string">&#x27;r&#x27;</span>); <span class="comment">% 使用阶梯图显示FM0编码结果</span></span><br><span class="line">title(<span class="string">&#x27;FM0 编码结果&#x27;</span>); <span class="comment">% 设置标题为&quot;FM0 编码结果&quot;</span></span><br><span class="line"><span class="comment">% 创建存储解码结果的向量，其长度为FM0编码长度的一半</span></span><br><span class="line">decoded_data = <span class="built_in">zeros</span>(<span class="number">1</span>, <span class="built_in">length</span>(FM0) / <span class="number">2</span>); </span><br><span class="line"><span class="comment">% 解码循环，从FM0编码结果中恢复原始数据</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span> = <span class="number">1</span>:<span class="number">2</span>:<span class="built_in">length</span>(FM0)<span class="number">-2</span></span><br><span class="line">    <span class="comment">% 如果两个相邻的FM0码元不同且下一对码元相同</span></span><br><span class="line">    <span class="keyword">if</span> (FM0(<span class="built_in">i</span>) ~= FM0(<span class="built_in">i</span>+<span class="number">1</span>)) &amp;&amp; (FM0(<span class="built_in">i</span>+<span class="number">1</span>) == FM0(<span class="built_in">i</span>+<span class="number">2</span>)) </span><br><span class="line">        decoded_data((<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>) = <span class="number">1</span>; <span class="comment">% 则解码为1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        decoded_data((<span class="built_in">i</span>+<span class="number">1</span>)/<span class="number">2</span>) = <span class="number">0</span>; <span class="comment">% 否则解码为0</span></span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line">subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>); <span class="comment">% 绘制解码后的数据</span></span><br><span class="line">stairs(<span class="number">0</span>:<span class="built_in">length</span>(decoded_data)<span class="number">-1</span>, decoded_data, <span class="string">&#x27;r&#x27;</span>); <span class="comment">% 使用阶梯图显示解码后的数据</span></span><br><span class="line">title(<span class="string">&#x27;FM0 解码结果&#x27;</span>); <span class="comment">% 设置标题为&quot;FM0 解码结果&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> RFID </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>随便写点</title>
      <link href="/2024/10/15/start/"/>
      <url>/2024/10/15/start/</url>
      
        <content type="html"><![CDATA[<p>欢迎来到我的博客! 如果感兴趣的话就多逛逛。不定期更新项目的经历，记录自己走过的路。这是我的<a href="https://github.com/xxxkkw">代码仓库</a>。</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
